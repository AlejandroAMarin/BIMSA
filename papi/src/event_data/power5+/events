{ File: power5+/events
{ Date: 12/13/06
{ Version: 1.7
{ Copyright (c) International Business Machines, 2006.
{ Contributed by Eric Kjeldergaard <kjelderg@linux.ibm.com>


362,356,355,352,1,1

{ counter 1 }
#0,v,g,n,n,PM_0INST_CLB_CYC,Cycles no instructions in CLB
##400C0
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#1,v,g,n,n,PM_1INST_CLB_CYC,Cycles 1 instruction in CLB
##400C1
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#2,v,g,n,n,PM_1PLUS_PPC_CMPL,One or more PPC instruction completed
##00013
A group containing at least one PPC instruction completed. For microcoded instructions that span multiple groups, this will only occur once.
#3,v,g,n,n,PM_2INST_CLB_CYC,Cycles 2 instructions in CLB
##400C2
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#4,v,g,n,n,PM_3INST_CLB_CYC,Cycles 3 instructions in CLB
##400C3
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#5,v,g,n,n,PM_4INST_CLB_CYC,Cycles 4 instructions in CLB
##400C4
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#6,v,g,n,n,PM_5INST_CLB_CYC,Cycles 5 instructions in CLB
##400C5
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#7,v,g,n,n,PM_6INST_CLB_CYC,Cycles 6 instructions in CLB
##400C6
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#8,u,g,n,s,PM_BRQ_FULL_CYC,Cycles branch queue full
##100C5
Cycles when the issue queue that feeds the branch unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#9,v,g,n,n,PM_BR_ISSUED,Branches issued
##230E4
A branch instruction was issued to the branch unit.  A branch that was incorrectly predicted may issue and execute multiple times.
#10,v,g,n,n,PM_BR_MPRED_CR,Branch mispredictions due to CR bit setting
##230E5
A conditional branch instruction was incorrectly predicted as taken or not taken.  The branch execution unit detects a branch mispredict because the CR value is opposite of the predicted value. This will result in a branch redirect flush if not overfidden by a flush of an older instruction.
#11,v,g,n,n,PM_BR_MPRED_TA,Branch mispredictions due to target address
##230E6
A branch instruction target was incorrectly predicted. This will result in a branch mispredict flush unless a flush is detected from an older instruction.
#12,v,g,n,n,PM_BR_UNCOND,Unconditional branch
##23087
An unconditional branch was executed.
#13,v,g,n,s,PM_CLB_EMPTY_CYC,Cycles CLB empty
##410C6
Cycles when both thread's CLB is completely empty.
#14,v,g,n,n,PM_CLB_FULL_CYC,Cycles CLB full
##220E5
Cycles when both thread's CLB is full.
#15,u,g,n,s,PM_CRQ_FULL_CYC,Cycles CR issue queue full
##110C1
The issue queue that feeds the Conditional Register unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#16,v,g,n,s,PM_CR_MAP_FULL_CYC,Cycles CR logical operation mapper full
##100C4
The Conditional Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#17,v,g,n,s,PM_CYC,Processor cycles
##0000F
Processor cycles
#18,v,g,n,n,PM_DATA_FROM_L2,Data loaded from L2
##C3087
The processor's Data Cache was reloaded from the local L2 due to a demand load.
#19,v,g,n,n,PM_DATA_FROM_L25_SHR,Data loaded from L2.5 shared
##C3097
The processor's Data Cache was reloaded with shared (T or SL) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#20,v,g,n,n,PM_DATA_FROM_L275_MOD,Data loaded from L2.75 modified
##C30A3
The processor's Data Cache was reloaded with modified (M) data from the L2 on a different module than this processor is located due to a demand load.
#21,v,g,n,n,PM_DATA_FROM_L3,Data loaded from L3
##C308E
The processor's Data Cache was reloaded from the local L3 due to a demand load.
#22,v,g,n,n,PM_DATA_FROM_L35_SHR,Data loaded from L3.5 shared
##C309E
The processor's Data Cache was reloaded with shared (S) data from the L3 of a chip on the same module as this processor is located due to a demand load.
#23,v,g,n,n,PM_DATA_FROM_L375_MOD,Data loaded from L3.75 modified
##C30A7
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a demand load.
#24,v,g,n,n,PM_DATA_FROM_RMEM,Data loaded from remote memory
##C30A1
The processor's Data Cache was reloaded from memory attached to a different module than this proccessor is located on.
#25,v,g,n,n,PM_DATA_TABLEWALK_CYC,Cycles doing data tablewalks
##800C7
Cycles a translation tablewalk is active.  While a tablewalk is active any request attempting to access the TLB will be rejected and retried.
#26,u,g,n,s,PM_DC_INV_L2,L1 D cache entries invalidated from L2
##C10C7
A dcache invalidated was received from the L2 because a line in L2 was castout.
#27,v,g,n,n,PM_DC_PREF_OUT_OF_STREAMS,D cache out of prefetch streams
##C50C2
A new prefetch stream was detected but no more stream entries were available.
#28,v,g,n,n,PM_DC_PREF_DST,DST (Data Stream Touch) stream start
##830E6
A prefetch stream was started using the DST instruction.
#29,v,g,n,n,PM_DC_PREF_STREAM_ALLOC,D cache new prefetch stream allocated
##830E7
A new Prefetch Stream was allocated.
#30,v,g,n,n,PM_DSLB_MISS,Data SLB misses
##800C5
A SLB miss for a data request occurred. SLB misses trap to the operating system to resolve.
#31,v,g,n,n,PM_DTLB_MISS,Data TLB misses
##800C4,C20E0
Data TLB misses, all page sizes.
#32,v,g,n,n,PM_DTLB_MISS_4K,Data TLB miss for 4K page
##C208D
Data TLB references to 4KB pages that missed the TLB. Page size is determined at TLB reload time.
#33,v,g,n,n,PM_DTLB_REF,Data TLB references
##C20E4
Total number of Data TLB references for all page sizes. Page size is determined at TLB reload time.
#34,v,g,n,n,PM_DTLB_REF_4K,Data TLB reference for 4K page
##C2086
Data TLB references for 4KB pages. Includes hits + misses.
#35,v,g,n,n,PM_EE_OFF,Cycles MSR(EE) bit off
##130E3
Cycles MSR(EE) bit was off indicating that interrupts due to external exceptions were masked.
#36,u,g,n,n,PM_EE_OFF_EXT_INT,Cycles MSR(EE) bit off and external interrupt pending
##130E7
Cycles when an interrupt due to an external exception is pending but external exceptions were masked.
#37,v,g,n,s,PM_FAB_CMD_ISSUED,Fabric command issued
##700C7
Incremented when a chip issues a command on its SnoopA address bus. Each of the two address busses (SnoopA and SnoopB) is capable of one transaction per fabric cycle (one fabric cycle = 2 cpu cycles in normal 2:1 mode), but each chip can only drive the SnoopA bus, and can only drive one transaction every two fabric cycles (i.e., every four cpu cycles). In MCM-based systems, two chips interleave their accesses to each of the two fabric busses (SnoopA, SnoopB) to reach a peak capability of one transaction per cpu clock cycle. The two chips that drive SnoopB are wired so that the chips refer to the bus as SnoopA but it is connected to the other two chips as SnoopB.  Note that this event will only be recorded by the FBC on the chip that sourced the operation. The signal is delivered at FBC speed and the count must be scaled.
#38,v,g,n,n,PM_FAB_CMD_RETRIED,Fabric command retried
##710C7
Incremented when a command issued by a chip on its SnoopA address bus is retried for any reason. The overwhelming majority of retries are due to running out of memory controller queues but retries can also be caused by trying to reference addresses that are in a transient cache state -- e.g. a line is transient after issuing a DCLAIM instruction to a shared line but before the associated store completes.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#39,v,g,n,s,PM_FAB_DCLAIM_ISSUED,dclaim issued
##720E7
A DCLAIM command was issued. Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#40,v,g,n,s,PM_FAB_DCLAIM_RETRIED,dclaim retried
##730E7
A DCLAIM command was retried.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#41,v,g,n,s,PM_FAB_HOLDtoNN_EMPTY,Hold buffer to NN empty
##722E7
Fabric cyles when the Next Node out hold-buffers are emtpy.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#42,v,g,n,s,PM_FAB_HOLDtoVN_EMPTY,Hold buffer to VN empty
##721E7
Fabric cycles when the Vertical Node out hold-buffers are emtpy. The signal is delivered at FBC speed and the count must be scaled accordingly.
#43,v,g,n,s,PM_FAB_M1toP1_SIDECAR_EMPTY,M1 to P1 sidecar empty
##702C7
Fabric cycles when the Minus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#44,v,g,n,s,PM_FAB_M1toVNorNN_SIDECAR_EMPTY,M1 to VN/NN sidecar empty
##712C7
Fabric cycles when the Minus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#45,v,g,n,s,PM_FAB_P1toM1_SIDECAR_EMPTY,P1 to M1 sidecar empty
##701C7
Fabric cycles when the Plus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#46,v,g,n,s,PM_FAB_P1toVNorNN_SIDECAR_EMPTY,P1 to VN/NN sidecar empty
##711C7
Fabric cycles when the Plus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#47,v,g,n,s,PM_FAB_PNtoNN_DIRECT,PN to NN beat went straight to its destination
##703C7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound NN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled.
#48,v,g,n,s,PM_FAB_PNtoNN_SIDECAR,PN to NN beat went to sidecar first
##713C7
Fabric Data beats that the base chip takes the inbound PN data and forwards it on to the outbound NN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled.
#49,v,g,n,s,PM_FAB_PNtoVN_DIRECT,PN to VN beat went straight to its destination
##723E7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound VN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled accordingly.
#50,v,g,n,s,PM_FAB_PNtoVN_SIDECAR,PN to VN beat went to sidecar first
##733E7
Fabric data beats that the base chip takes the inbound PN data and forwards it on to the outbound VN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled accordingly.
#51,v,g,n,s,PM_FAB_VBYPASS_EMPTY,Vertical bypass buffer empty
##731E7
Fabric cycles when the Middle Bypass sidecar is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#52,v,g,n,n,PM_FLUSH,Flushes
##110C7
Flushes occurred including LSU and Branch flushes.
#53,v,g,n,n,PM_FLUSH_BR_MPRED,Flush caused by branch mispredict
##110C6
A flush was caused by a branch mispredict.
#54,v,g,n,s,PM_FLUSH_IMBAL,Flush caused by thread GCT imbalance
##330E3
This thread has been flushed at dispatch because it is stalled and a GCT imbalance exists.  GCT thresholds are set in the TSCR register. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#55,v,g,n,s,PM_FLUSH_SB,Flush caused by scoreboard operation
##330E2
This thread has been flushed at dispatch because its scoreboard bit is set indicating that a non-renamed resource is being updated. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#56,v,g,n,s,PM_FLUSH_SYNC,Flush caused by sync
##330E1
This thread has been flushed at dispatch due to a sync, lwsync, ptesync, or tlbsync instruction.  This allows the other thread to have more machine resources for it to make progress until the sync finishes.
#57,v,g,n,s,PM_FPR_MAP_FULL_CYC,Cycles FPR mapper full
##100C1
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#58,v,g,n,n,PM_FPU0_1FLOP,FPU0 executed add, mult, sub, cmp or sel instruction
##000C3
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#59,v,g,n,n,PM_FPU0_DENORM,FPU0 received denormalized data
##020E0
FPU0 has encountered a denormalized operand.
#60,v,g,n,n,PM_FPU0_FDIV,FPU0 executed FDIV instruction
##000C0
FPU0 has executed a divide instruction. This could be fdiv, fdivs, fdiv. fdivs.
#61,v,g,n,n,PM_FPU0_FEST,FPU0 executed FEST instruction
##010C2
FPU0 has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#62,v,g,n,n,PM_FPU0_FIN,FPU0 produced a result
##010C3
FPU0 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads.
#63,v,g,n,n,PM_FPU0_FMA,FPU0 executed multiply-add instruction
##000C1
The floating point unit has executed a multiply-add kind of instruction.  This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#64,v,g,n,n,PM_FPU0_FMOV_FEST,FPU0 executed FMOV or FEST instructions
##010C0
FPU0 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#65,v,g,n,n,PM_FPU0_FPSCR,FPU0 executed FPSCR instruction
##030E0
FPU0 has executed FPSCR move related instruction. This could be mtfsfi*, mtfsb0*, mtfsb1*, mffs*, mtfsf*, mcrsf* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#66,v,g,n,n,PM_FPU0_FRSP_FCONV,FPU0 executed FRSP or FCONV instructions
##010C1
FPU0 has executed a frsp or convert kind of instruction. This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#67,v,g,n,n,PM_FPU0_FSQRT,FPU0 executed FSQRT instruction
##000C2
FPU0 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#68,v,g,n,s,PM_FPU0_FULL_CYC,Cycles FPU0 issue queue full
##100C3
The issue queue for FPU0 cannot accept any more instruction. Dispatch to this issue queue is stopped.
#69,v,g,n,n,PM_FPU0_SINGLE,FPU0 executed single precision instruction
##020E3
FPU0 has executed a single precision instruction.
#70,v,g,n,n,PM_FPU0_STALL3,FPU0 stalled in pipe3
##020E1
FPU0 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#71,v,g,n,n,PM_FPU0_STF,FPU0 executed store instruction
##020E2
FPU0 has executed a Floating Point Store instruction.
#72,v,g,n,n,PM_FPU1_1FLOP,FPU1 executed add, mult, sub, cmp or sel instruction
##000C7
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#73,v,g,n,n,PM_FPU1_DENORM,FPU1 received denormalized data
##020E4
FPU1 has encountered a denormalized operand.
#74,v,g,n,n,PM_FPU1_FDIV,FPU1 executed FDIV instruction
##000C4
FPU1 has executed a divide instruction.  This could be fdiv, fdivs, fdiv. fdivs.
#75,v,g,n,n,PM_FPU1_FEST,FPU1 executed FEST instruction
##010C6
FPU1 has executed an estimate instructions.  This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#76,v,g,n,n,PM_FPU1_FIN,FPU1 produced a result
##010C7
FPU1 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads., ,
#77,v,g,n,n,PM_FPU1_FMA,FPU1 executed multiply-add instruction
##000C5
The floating point unit has executed a multiply-add kind of instruction. This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#78,v,g,n,n,PM_FPU1_FMOV_FEST,FPU1 executed FMOV or FEST instructions
##010C4
FPU1 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#79,v,g,n,n,PM_FPU1_FRSP_FCONV,FPU1 executed FRSP or FCONV instructions
##010C5
FPU1 has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#80,v,g,n,n,PM_FPU1_FSQRT,FPU1 executed FSQRT instruction
##000C6
FPU1 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#81,v,g,n,s,PM_FPU1_FULL_CYC,Cycles FPU1 issue queue full
##100C7
The issue queue for FPU1 cannot accept any more instructions. Dispatch to this issue queue is stopped
#82,v,g,n,n,PM_FPU1_SINGLE,FPU1 executed single precision instruction
##020E7
FPU1 has executed a single precision instruction.
#83,v,g,n,n,PM_FPU1_STALL3,FPU1 stalled in pipe3
##020E5
FPU1 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#84,v,g,n,n,PM_FPU1_STF,FPU1 executed store instruction
##020E6
FPU1 has executed a Floating Point Store instruction.
#85,v,g,n,n,PM_FPU_1FLOP,FPU executed one flop instruction
##00090
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#86,v,g,n,n,PM_FPU_DENORM,FPU received denormalized data
##02088
The floating point unit has encountered a denormalized operand.  Combined Unit 0 + Unit 1.
#87,v,g,n,n,PM_FPU_FDIV,FPU executed FDIV instruction
##00088
The floating point unit has executed a divide instruction. This could be fdiv, fdivs, fdiv., fdivs.. Combined Unit 0 + Unit 1.
#88,v,g,n,n,PM_FPU_FEST,FPU executed FEST instruction
##010A8
The floating point unit has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or  XYZ.   Combined Unit 0 + Unit 1.
#89,c,g,n,n,PM_FPU_FULL_CYC,Cycles FPU issue queue full
##10090
Cycles when one or both FPU issue queues are full.  Combined Unit 0 + 1.  Use with caution since this is the sum of cycles when Unit 0 was full plus Unit 1 full.  It does not indicate when both units were full.
#90,v,g,n,n,PM_FPU_SINGLE,FPU executed single precision instruction
##02090
FPU is executing single precision instruction. Combined Unit 0 + Unit 1.
#91,v,g,n,s,PM_FXLS0_FULL_CYC,Cycles FXU0/LS0 queue full
##110C0
The issue queue that feeds the Fixed Point unit 0 / Load Store Unit 0 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#92,v,g,n,s,PM_FXLS1_FULL_CYC,Cycles FXU1/LS1 queue full
##110C4
The issue queue that feeds the Fixed Point unit 1 / Load Store Unit 1 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#93,c,g,n,n,PM_FXLS_FULL_CYC,Cycles FXLS queue is full
##110A8
Cycles when the issue queues for one or both FXU/LSU units is full.  Use with caution since this is the sum of cycles when Unit 0 was full plus Unit 1 full.  It does not indicate when both units were full.
#94,v,g,n,n,PM_FXU0_FIN,FXU0 produced a result
##130E2
The Fixed Point unit 0 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#95,v,g,n,n,PM_FXU1_FIN,FXU1 produced a result
##130E6
The Fixed Point unit 1 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#96,u,g,n,n,PM_FXU_IDLE,FXU idle
##00012
FXU0 and FXU1 are both idle.
#97,v,g,n,n,PM_GCT_FULL_CYC,Cycles GCT full
##100C0
The Global Completion Table is completely full.
#98,v,g,n,n,PM_GCT_NOSLOT_CYC,Cycles no GCT slot allocated
##00004
Cycles when the Global Completion Table has no slots from this thread.
#99,v,g,n,s,PM_GCT_USAGE_00to59_CYC,Cycles GCT less than 60% full
##0001F
Cycles when the Global Completion Table has fewer than 60% of its slots used.  The GCT has 20 entries shared between threads.
#100,v,g,n,s,PM_GPR_MAP_FULL_CYC,Cycles GPR mapper full
##130E5
The General Purpose Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#101,v,g,n,n,PM_GRP_BR_REDIR,Group experienced branch redirect
##120E6
Number of groups, counted at dispatch, that have encountered a branch redirect.  Every group constructed from a fetch group that has been redirected will count.
#102,v,g,n,n,PM_GRP_BR_REDIR_NONSPEC,Group experienced non-speculative branch redirect
##12091
Number of groups, counted at completion, that have encountered a branch redirect.
#103,v,g,n,n,PM_GRP_DISP_BLK_SB_CYC,Cycles group dispatch blocked by scoreboard
##130E1
A scoreboard operation on a non-renamed resource has blocked dispatch.
#104,v,g,n,n,PM_GRP_DISP_REJECT,Group dispatch rejected
##120E4
A group that previously attempted dispatch was rejected.
#105,v,g,n,n,PM_GRP_DISP_VALID,Group dispatch valid
##120E3
A group is available for dispatch.  This does not mean it was successfully dispatched.
#106,v,g,n,n,PM_GRP_IC_MISS,Group experienced I cache miss
##120E7
Number of groups, counted at dispatch, that have encountered an icache miss redirect.  Every group constructed from a fetch group that missed the instruction cache will count.
#107,c,g,n,n,PM_GRP_IC_MISS_BR_REDIR_NONSPEC,Group experienced non-speculative I cache miss or branch redirect
##120E5
Group experienced non-speculative I cache miss or branch redirect
#108,v,g,n,n,PM_GRP_IC_MISS_NONSPEC,Group experienced non-speculative I cache miss
##12099
Number of groups, counted at completion, that have encountered an instruction cache miss.
#109,v,g,n,n,PM_GRP_MRK,Group marked in IDU
##00014
A group was sampled (marked).  The group is called a marked group.  One instruction within the group is tagged for detailed monitoring.  The sampled instruction is called a marked instructions.  Events associated with the marked instruction are annotated with the marked term.
#110,v,g,n,n,PM_IC_DEMAND_L2_BHT_REDIRECT,L2 I cache demand request due to BHT redirect
##230E0
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (CR mispredict).
#111,v,g,n,n,PM_IC_DEMAND_L2_BR_REDIRECT,L2 I cache demand request due to branch redirect
##230E1
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (either ALL mispredicted or Target).
#112,v,g,n,n,PM_IC_PREF_REQ,Instruction prefetch requests
##220E6
An instruction prefetch request has been made.
#113,v,g,n,n,PM_IERAT_XLATE_WR,Translation written to ierat
##220E7
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#114,v,g,n,n,PM_IERAT_XLATE_WR_LP,Large page translation written to ierat
##210C6
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#115,v,g,n,n,PM_IOPS_CMPL,Internal operations completed
##00001
Number of internal operations that completed.
#116,v,g,n,n,PM_INST_DISP_ATTEMPT,Instructions dispatch attempted
##120E1
Number of PowerPC Instructions dispatched (attempted, not filtered by success.
#117,v,g,n,n,PM_INST_FETCH_CYC,Cycles at least 1 instruction fetched
##220E4
Cycles when at least one instruction was sent from the fetch unit to the decode unit.
#118,v,g,n,n,PM_INST_FROM_L2,Instruction fetched from L2
##22086
An instruction fetch group was fetched from L2. Fetch Groups can contain up to 8 instructions
#119,v,g,n,n,PM_INST_FROM_L25_SHR,Instruction fetched from L2.5 shared
##22096
An instruction fetch group was fetched with shared  (T or SL) data from the L2 of a chip on the same module as this processor is located. Fetch groups can contain up to 8 instructions.
#120,v,g,n,n,PM_INST_FROM_L2MISS,Instruction fetched missed L2
##2209B
An instruction fetch group was fetched from beyond the local L2.
#121,v,g,n,n,PM_INST_FROM_L3,Instruction fetched from L3
##2208D
An instruction fetch group was fetched from the local L3. Fetch groups can contain up to 8 instructions
#122,v,g,n,n,PM_INST_FROM_L35_SHR,Instruction fetched from L3.5 shared
##2209D
An instruction fetch group was fetched with shared (S) data from the L3 of a chip on the same module as this processor is located. Fetch groups can contain up to 8 instructions
#123,u,g,n,n,PM_ISLB_MISS,Instruction SLB misses
##800C1
A SLB miss for an instruction fetch as occurred
#124,v,g,n,n,PM_ITLB_MISS,Instruction TLB misses
##800C0
A TLB miss for an Instruction Fetch has occurred
#125,v,g,n,n,PM_L1_DCACHE_RELOAD_VALID,L1 reload data source valid
##C30E4
The data source information is valid,the data cache has been reloaded.  Prior to POWER5+ this included data cache reloads due to prefetch activity.  With POWER5+ this now only includes reloads due to demand loads.
#126,v,g,n,n,PM_L1_PREF,L1 cache data prefetches
##C70E7
A request to prefetch data into the L1 was made
#127,v,g,n,n,PM_L1_WRITE_CYC,Cycles writing to instruction L1
##230E7
Cycles that a cache line was written to the instruction cache.
#128,v,g,n,s,PM_L2SA_MOD_INV,L2 slice A transition from modified to invalid
##730E0
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#129,v,g,n,s,PM_L2SA_MOD_TAG,L2 slice A transition from modified to tagged
##720E0
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#130,v,g,n,s,PM_L2SA_RCLD_DISP,L2 slice A RC load dispatch attempt
##701C0
A Read/Claim dispatch for a Load was attempted
#131,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_ADDR,L2 slice A RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C0
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#132,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_OTHER,L2 slice A RC load dispatch attempt failed due to other reasons
##731E0
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#133,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_RC_FULL,L2 slice A RC load dispatch attempt failed due to all RC full
##721E0
A Read/Claim dispatch for a load failed because all RC machines are busy.
#134,v,g,n,s,PM_L2SA_RCST_DISP,L2 slice A RC store dispatch attempt
##702C0
A Read/Claim dispatch for a Store was attempted.
#135,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_ADDR,L2 slice A RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C0
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#136,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_OTHER,L2 slice A RC store dispatch attempt failed due to other reasons
##732E0
A Read/Claim dispatch for a store failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#137,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_RC_FULL,L2 slice A RC store dispatch attempt failed due to all RC full
##722E0
A Read/Claim dispatch for a store failed because all RC machines are busy.
#138,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY,L2 slice A RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C0
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#139,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice A RC dispatch attempt failed due to all CO busy
##713C0
A Read/Claim dispatch was rejected because all Castout machines were busy.
#140,v,g,n,s,PM_L2SA_SHR_INV,L2 slice A transition from shared to invalid
##710C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#141,v,g,n,s,PM_L2SA_SHR_MOD,L2 slice A transition from shared to modified
##700C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#142,v,g,n,n,PM_L2SA_ST_HIT,L2 slice A store hits
##733E0
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B, and C.
#143,v,g,n,n,PM_L2SA_ST_REQ,L2 slice A store requests
##723E0
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#144,v,g,n,s,PM_L2SB_MOD_INV,L2 slice B transition from modified to invalid
##730E1
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#145,v,g,n,s,PM_L2SB_MOD_TAG,L2 slice B transition from modified to tagged
##720E1
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#146,v,g,n,s,PM_L2SB_RCLD_DISP,L2 slice B RC load dispatch attempt
##701C1
A Read/Claim dispatch for a Load was attempted
#147,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_ADDR,L2 slice B RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C1
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#148,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_OTHER,L2 slice B RC load dispatch attempt failed due to other reasons
##731E1
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#149,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_RC_FULL,L2 slice B RC load dispatch attempt failed due to all RC full
##721E1
A Read/Claim dispatch for a load failed because all RC machines are busy.
#150,v,g,n,s,PM_L2SB_RCST_DISP,L2 slice B RC store dispatch attempt
##702C1
A Read/Claim dispatch for a Store was attempted.
#151,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_ADDR,L2 slice B RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C1
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#152,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_OTHER,L2 slice B RC store dispatch attempt failed due to other reasons
##732E1
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#153,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_RC_FULL,L2 slice B RC store dispatch attempt failed due to all RC full
##722E2
A Read/Claim dispatch for a store failed because all RC machines are busy.
#154,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY,L2 slice B RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C1
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#155,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice B RC dispatch attempt failed due to all CO busy
##713C1
A Read/Claim dispatch was rejected because all Castout machines were busy.
#156,v,g,n,s,PM_L2SB_SHR_INV,L2 slice B transition from shared to invalid
##710C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#157,v,g,n,s,PM_L2SB_SHR_MOD,L2 slice B transition from shared to modified
##700C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#158,v,g,n,n,PM_L2SB_ST_HIT,L2 slice B store hits
##733E1
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B and C.
#159,v,g,n,n,PM_L2SB_ST_REQ,L2 slice B store requests
##723E1
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#160,v,g,n,s,PM_L2SC_MOD_INV,L2 slice C transition from modified to invalid
##730E2
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#161,v,g,n,s,PM_L2SC_MOD_TAG,L2 slice C transition from modified to tagged
##720E2
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#162,v,g,n,s,PM_L2SC_RCLD_DISP,L2 slice C RC load dispatch attempt
##701C2
A Read/Claim dispatch for a Load was attempted
#163,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_ADDR,L2 slice C RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C2
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#164,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_OTHER,L2 slice C RC load dispatch attempt failed due to other reasons
##731E2
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#165,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_RC_FULL,L2 slice C RC load dispatch attempt failed due to all RC full
##721E2
A Read/Claim dispatch for a load failed because all RC machines are busy.
#166,v,g,n,s,PM_L2SC_RCST_DISP,L2 slice C RC store dispatch attempt
##702C2
A Read/Claim dispatch for a Store was attempted.
#167,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_ADDR,L2 slice C RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C2
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#168,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_OTHER,L2 slice C RC store dispatch attempt failed due to other reasons
##732E2
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#169,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_RC_FULL,L2 slice C RC store dispatch attempt failed due to all RC full
##722E1
A Read/Claim dispatch for a store failed because all RC machines are busy.
#170,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY,L2 slice C RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C2
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#171,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice C RC dispatch attempt failed due to all CO busy
##713C2
A Read/Claim dispatch was rejected because all Castout machines were busy.
#172,v,g,n,s,PM_L2SC_SHR_INV,L2 slice C transition from shared to invalid
##710C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#173,v,g,n,s,PM_L2SC_SHR_MOD,L2 slice C transition from shared to modified
##700C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#174,v,g,n,n,PM_L2SC_ST_HIT,L2 slice C store hits
##733E2
A store request made from the core hit in the L2 directory.  The event is provided on each of the  three slices A, B, and C.
#175,v,g,n,n,PM_L2SC_ST_REQ,L2 slice C store requests
##723E2
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#176,v,g,n,n,PM_L2_PREF,L2 cache prefetches
##C50C3
A request to prefetch data into L2 was made
#177,v,g,n,s,PM_L3SA_ALL_BUSY,L3 slice A active for every cycle all CI/CO machines busy
##721E3
Cycles All Castin/Castout machines are busy.
#178,v,g,n,s,PM_L3SA_HIT,L3 slice A hits
##711C3
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#179,v,g,n,s,PM_L3SA_MOD_INV,L3 slice A transition from modified to invalid
##730E3
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#180,v,g,n,s,PM_L3SA_MOD_TAG,L3 slice A transition from modified to TAG
##720E3
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case) Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#181,v,g,n,s,PM_L3SA_REF,L3 slice A references
##701C3
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#182,v,g,n,s,PM_L3SA_SHR_INV,L3 slice A transition from shared to invalid
##710C3
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#183,v,g,n,s,PM_L3SA_SNOOP_RETRY,L3 slice A snoop retries
##731E3
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#184,v,g,n,s,PM_L3SB_ALL_BUSY,L3 slice B active for every cycle all CI/CO machines busy
##721E4
Cycles All Castin/Castout machines are busy.
#185,v,g,n,s,PM_L3SB_HIT,L3 slice B hits
##711C4
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#186,v,g,n,s,PM_L3SB_MOD_INV,L3 slice B transition from modified to invalid
##730E4
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I).  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#187,v,g,n,s,PM_L3SB_MOD_TAG,L3 slice B transition from modified to TAG
##720E4
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#188,v,g,n,s,PM_L3SB_REF,L3 slice B references
##701C4
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#189,v,g,n,s,PM_L3SB_SHR_INV,L3 slice B transition from shared to invalid
##710C4
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#190,v,g,n,s,PM_L3SB_SNOOP_RETRY,L3 slice B snoop retries
##731E4
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#191,v,g,n,s,PM_L3SC_ALL_BUSY,L3 slice C active for every cycle all CI/CO machines busy
##721E5
Cycles All Castin/Castout machines are busy.
#192,v,g,n,s,PM_L3SC_HIT,L3 slice C hits
##711C5
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 Slice
#193,v,g,n,s,PM_L3SC_MOD_INV,L3 slice C transition from modified to invalid
##730E5
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a previous read op Tx is not included since it is considered shared at this point.
#194,v,g,n,s,PM_L3SC_MOD_TAG,L3 slice C transition from modified to TAG
##720E5
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#195,v,g,n,s,PM_L3SC_REF,L3 slice C references
##701C5
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice.
#196,v,g,n,s,PM_L3SC_SHR_INV,L3 slice C transition from shared to invalid
##710C5
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#197,v,g,n,s,PM_L3SC_SNOOP_RETRY,L3 slice C snoop retries
##731E5
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#198,v,g,n,n,PM_LARX_LSU0,Larx executed on LSU0
##820E7
A larx (lwarx or ldarx) was executed on side 0 (there is no corresponding unit 1 event since larx instructions can only execute on unit 0)
#199,v,g,n,n,PM_LD_MISS_L1_LSU0,LSU0 L1 D cache load misses
##C10C2
Load references that miss the Level 1 Data cache, by unit 0.
#200,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C5,C10C6
Load references that miss the Level 1 Data cache, by unit 1.
#201,v,g,n,n,PM_LD_REF_L1,L1 D cache load references
##C10A8
Load references to the Level 1 Data Cache. Combined unit 0 + 1.
#202,v,g,n,n,PM_LD_REF_L1_LSU0,LSU0 L1 D cache load references
##C10C0
Load references to Level 1 Data Cache, by unit 0.
#203,v,g,n,n,PM_BR_PRED_TA,A conditional branch was predicted, target prediction
##230E3
The target address of a branch instruction was predicted.
#204,u,g,n,s,PM_LR_CTR_MAP_FULL_CYC,Cycles LR/CTR mapper full
##100C6
The LR/CTR mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#205,v,g,n,n,PM_LSU0_BUSY_REJECT,LSU0 busy due to reject
##C20E1
Total cycles the Load Store Unit 0 is busy rejecting instructions.
#206,v,g,n,n,PM_LSU0_DERAT_MISS,LSU0 DERAT misses
##800C2
Total D-ERAT Misses by LSU0.   Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.
#207,v,g,n,n,PM_LSU0_FLUSH_LRQ,LSU0 LRQ flushes
##C00C2
A load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#208,u,g,n,n,PM_LSU0_FLUSH_SRQ,LSU0 SRQ lhs flushes
##C00C3
A store was flushed by unit 0 because younger load hits and older store that is already in the SRQ or in the same group.
#209,v,g,n,n,PM_LSU0_FLUSH_ULD,LSU0 unaligned load flushes
##C00C0
A load was flushed from unit 0 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1)
#210,v,g,n,n,PM_LSU0_FLUSH_UST,LSU0 unaligned store flushes
##C00C1
A store was flushed from unit 0 because it was unaligned (crossed a 4K boundary).
#211,v,g,n,n,PM_LSU0_LDF,LSU0 executed Floating Point load instruction
##C50C0
A floating point load was executed by LSU0
#212,v,g,n,n,PM_LSU0_NCLD,LSU0 non-cacheable loads
##C50C1
A non-cacheable load was executed by unit 0.
#213,v,g,n,n,PM_LSU0_REJECT_ERAT_MISS,LSU0 reject due to ERAT miss
##C40C3
Total cycles the Load Store Unit 0 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#214,v,g,n,n,PM_LSU0_REJECT_LMQ_FULL,LSU0 reject due to LMQ full or missed data coming
##C40C1
Total cycles the Load Store Unit 0 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#215,v,g,n,n,PM_LSU0_REJECT_RELOAD_CDF,LSU0 reject due to reload CDF or tag update collision
##C40C2
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#216,v,g,n,n,PM_LSU0_REJECT_SRQ,LSU0 SRQ lhs rejects
##C40C0
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#217,u,g,n,n,PM_LSU0_SRQ_STFWD,LSU0 SRQ store forwarded
##C60E1
Data from a store instruction was forwarded to a load on unit 0.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#218,v,g,n,n,PM_LSU1_BUSY_REJECT,LSU1 busy due to reject
##C20E5
Total cycles the Load Store Unit 1 is busy rejecting instructions.
#219,v,g,n,n,PM_LSU1_DERAT_MISS,LSU1 DERAT misses
##800C6
A data request (load or store) from LSU Unit 1 missed the ERAT and resulted in an ERAT reload. Multiple instructions may miss the ERAT entry for the same 4K page, but only one reload will occur.
#220,v,g,n,n,PM_LSU1_FLUSH_LRQ,LSU1 LRQ flushes
##C00C6
A load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#221,u,g,n,n,PM_LSU1_FLUSH_SRQ,LSU1 SRQ lhs flushes
##C00C7
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#222,v,g,n,n,PM_LSU1_FLUSH_ULD,LSU1 unaligned load flushes
##C00C4
A load was flushed from unit 1 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1).
#223,u,g,n,n,PM_LSU1_FLUSH_UST,LSU1 unaligned store flushes
##C00C5
A store was flushed from unit 1 because it was unaligned (crossed a 4K boundary)
#224,v,g,n,n,PM_LSU1_LDF,LSU1 executed Floating Point load instruction
##C50C4
A floating point load was executed by LSU1
#225,v,g,n,n,PM_LSU1_NCLD,LSU1 non-cacheable loads
##C50C5
A non-cacheable load was executed by Unit 0.
#226,v,g,n,n,PM_LSU1_REJECT_ERAT_MISS,LSU1 reject due to ERAT miss
##C40C7
Total cycles the Load Store Unit 1 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#227,v,g,n,n,PM_LSU1_REJECT_LMQ_FULL,LSU1 reject due to LMQ full or missed data coming
##C40C5
Total cycles the Load Store Unit 1 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#228,v,g,n,n,PM_LSU1_REJECT_RELOAD_CDF,LSU1 reject due to reload CDF or tag update collision
##C40C6
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#229,v,g,n,n,PM_LSU1_REJECT_SRQ,LSU1 SRQ lhs rejects
##C40C4
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#230,u,g,n,n,PM_LSU1_SRQ_STFWD,LSU1 SRQ store forwarded
##C60E5
Data from a store instruction was forwarded to a load on unit 1.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#231,v,g,n,n,PM_LSU_FLUSH,Flush initiated by LSU
##110C5
A flush was initiated by the Load Store Unit
#232,v,g,n,s,PM_LSU_FLUSH_LRQ_FULL,Flush caused by LRQ full
##320E7
This thread was flushed at dispatch because its Load Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#233,u,g,n,n,PM_LSU_FLUSH_SRQ,SRQ flushes
##C0090
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.  Combined Unit 0 + 1.
#234,v,g,n,s,PM_LSU_FLUSH_SRQ_FULL,Flush caused by SRQ full
##330E0
This thread was flushed at dispatch because its Store Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#235,v,g,n,n,PM_LSU_FLUSH_ULD,LRQ unaligned load flushes
##C0088
A load was flushed because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1).  Combined Unit 0 + 1.
#236,v,g,n,n,PM_LSU_LDF,LSU executed Floating Point load instruction
##C50A8
LSU executed Floating Point load instruction.  Combined Unit 0 + 1.
#237,u,g,n,s,PM_LSU_LMQ_FULL_CYC,Cycles LMQ full
##C30E7
The Load Miss Queue was full.
#238,v,g,n,n,PM_LSU_LMQ_LHR_MERGE,LMQ LHR merges
##C70E5
A data cache miss occurred for the same real cache line address as an earlier request already in the Load Miss Queue and was merged into the LMQ entry.
#239,v,g,n,s,PM_LSU_LMQ_S0_ALLOC,LMQ slot 0 allocated
##C30E6
The first entry in the LMQ was allocated.
#240,v,g,n,n,PM_LSU_LMQ_S0_VALID,LMQ slot 0 valid
##C30E5
This signal is asserted every cycle when the first entry in the LMQ is valid. The LMQ had eight entries that are allocated FIFO
#241,v,g,n,s,PM_LSU_LRQ_FULL_CYC,Cycles LRQ full
##110C2
Cycles when the LRQ is full.
#242,v,g,n,n,PM_LSU_LRQ_S0_ALLOC,LRQ slot 0 allocated
##C60E7
LRQ slot zero was allocated
#243,v,g,n,n,PM_LSU_LRQ_S0_VALID,LRQ slot 0 valid
##C60E6
This signal is asserted every cycle that the Load Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the LRQ is split between the two threads (16 entries each).
#244,v,g,n,n,PM_LSU_REJECT_ERAT_MISS,LSU reject due to ERAT miss
##C4090
Total cycles the Load Store Unit is busy rejecting instructions due to an ERAT miss. Combined unit 0 + 1. Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#245,v,g,n,n,PM_LSU_REJECT_SRQ,LSU SRQ lhs rejects
##C4088
Total cycles the Load Store Unit is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.  Combined Unit 0 + 1.
#246,v,g,n,s,PM_LSU_SRQ_FULL_CYC,Cycles SRQ full
##110C3
Cycles the Store Request Queue is full.
#247,v,g,n,n,PM_LSU_SRQ_S0_ALLOC,SRQ slot 0 allocated
##C20E7
SRQ Slot zero was allocated
#248,v,g,n,n,PM_LSU_SRQ_S0_VALID,SRQ slot 0 valid
##C20E6
This signal is asserted every cycle that the Store Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the SRQ is split between the two threads (16 entries each).
#249,u,g,n,n,PM_LSU_SRQ_SYNC_CYC,SRQ sync duration
##830E5
Cycles that a sync instruction is active in the Store Request Queue.
#250,v,g,n,n,PM_LWSYNC_HELD,LWSYNC held at dispatch
##130E0
Cycles a LWSYNC instruction was held at dispatch. LWSYNC instructions are held at dispatch until all previous loads are done and all previous stores have issued. LWSYNC enters the Store Request Queue and is sent to the storage subsystem but does not wait for a response.
#251,c,g,n,n,PM_MEM_FAST_PATH_RD_DISP,Fast path memory read dispatched
##731E6
Fast path memory read dispatched
#252,v,g,n,n,PM_IC_PREF_INSTALL,Instruction prefetched installed in prefetch buffer
##210C7
A prefetch buffer entry (line) is allocated but the request is not a demand fetch.
#253,v,g,n,s,PM_MEM_HI_PRIO_WR_CMPL,High priority write completed
##726E6
A memory write,  which was upgraded to high priority, completed.  Writes can be upgraded to high priority to ensure that read traffic does not lock out writes. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#254,v,g,n,s,PM_MEM_NONSPEC_RD_CANCEL,Non speculative memory read cancelled
##711C6
A non-speculative read was cancelled because the combined response indicated it was sourced from aother L2 or L3.   This event is sent from the Memory Controller clock domain and must be scaled accordingly
#255,v,g,n,s,PM_MEM_LO_PRIO_WR_CMPL,Low priority write completed
##736E6
A memory write,  which was not upgraded to high priority, completed.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#256,v,g,n,s,PM_MEM_PWQ_DISP,Memory partial-write queue dispatched
##704C6
Number of Partial Writes dispatched.  The MC provides resources to gather partial cacheline writes (Partial line DMA writes & CI-stores) to up to four different cachelines at a time.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#257,v,g,n,n,PM_MEM_PWQ_DISP_Q2or3,Memory partial-write queue dispatched to Write Queue 2 or 3
##734E6
Memory partial-write queue dispatched to Write Queue 2 or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#258,v,g,n,s,PM_MEM_PW_CMPL,Memory partial-write completed
##724E6
Number of Partial Writes completed.   This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#259,v,g,n,s,PM_MEM_PW_GATH,Memory partial-write gathered
##714C6
Two or more partial-writes have been merged into a single memory write. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#260,v,g,n,n,PM_MEM_RQ_DISP_Q0to3,Memory read queue dispatched to queues 0-3
##702C6
A memory operation was dispatched to read queue 0,1,2, or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#261,v,g,n,s,PM_MEM_RQ_DISP,Memory read queue dispatched
##701C6
A memory read was dispatched. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#262,v,g,n,n,PM_MEM_RQ_DISP_Q4to7,Memory read queue dispatched to queues 4-7
##712C6
A memory operation was dispatched to read queue 4,5,6 or 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#263,v,g,n,n,PM_MEM_RQ_DISP_Q8to11,Memory read queue dispatched to queues 8-11
##722E6
A memory operation was dispatched to read queue 8,9,10 or 11. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#264,v,g,n,s,PM_MEM_SPEC_RD_CANCEL,Speculative memory read cancelled
##721E6
Speculative memory read cancelled (i.e. cresp = sourced by L2/L3)
#265,v,g,n,n,PM_MEM_WQ_DISP_Q0to7,Memory write queue dispatched to queues 0-7
##723E6
A memory operation was dispatched to a write queue in the range between 0 and 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#266,v,g,n,n,PM_MEM_WQ_DISP_Q8to15,Memory write queue dispatched to queues 8-15
##733E6
A memory operation was dispatched to a write queue in the range between 8 and 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#267,v,g,n,s,PM_MEM_WQ_DISP_DCLAIM,Memory write queue dispatched due to dclaim/flush
##713C6
A memory dclaim or flush operation was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#268,v,g,n,s,PM_MEM_WQ_DISP_WRITE,Memory write queue dispatched due to write
##703C6
A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#269,v,g,n,n,PM_MRK_DATA_FROM_L2,Marked data loaded from L2
##C7087
The processor's Data Cache was reloaded from the local L2 due to a marked load.
#270,v,g,n,n,PM_MRK_DATA_FROM_L25_SHR,Marked data loaded from L2.5 shared
##C7097
The processor's Data Cache was reloaded with shared  (T or SL) data from the L2 of a chip on the same module as this processor is located due to a marked load.
#271,v,g,n,n,PM_MRK_DATA_FROM_L275_MOD,Marked data loaded from L2.75 modified
##C70A3
The processor's Data Cache was reloaded with modified (M) data from the L2 on a different module than this processor is located due to a marked load.
#272,v,g,n,n,PM_MRK_DATA_FROM_L3,Marked data loaded from L3
##C708E
The processor's Data Cache was reloaded from the local L3 due to a marked load.
#273,v,g,n,n,PM_MRK_DATA_FROM_L35_SHR,Marked data loaded from L3.5 shared
##C709E
The processor's Data Cache was reloaded with shared (S) data from the L3 of a chip on the same module as this processor is located due to a marked load.
#274,v,g,n,n,PM_MRK_DATA_FROM_L375_MOD,Marked data loaded from L3.75 modified
##C70A7
The processor's Data Cache was reloaded with modified  (M) data from the L3 of a chip on a different module than this processor is located due to a marked load.
#275,v,g,n,n,PM_MRK_DATA_FROM_RMEM,Marked data loaded from remote memory
##C70A1
The processor's Data Cache was reloaded due to a marked load from memory attached to a different module than this proccessor is located on.
#276,v,g,n,n,PM_MRK_DSLB_MISS,Marked Data SLB misses
##C50C7
A Data SLB miss was caused by a marked instruction.
#277,v,g,n,n,PM_MRK_DTLB_MISS,Marked Data TLB misses
##C50C6,C60E0
Data TLB references by a marked instruction that missed the TLB (all page sizes).
#278,v,g,n,n,PM_MRK_DTLB_MISS_4K,Marked Data TLB misses for 4K page
##C608D
Data TLB references to 4KB pages by a marked instruction that missed the TLB. Page size is determined at TLB reload time.
#279,v,g,n,n,PM_MRK_DTLB_REF,Marked Data TLB reference
##C60E4
Total number of Data TLB references by a marked instruction for all page sizes. Page size is determined at TLB reload time.
#280,v,g,n,n,PM_MRK_DTLB_REF_4K,Marked Data TLB reference for 4K page
##C6086
Data TLB references by a marked instruction for 4KB pages.
#281,v,g,n,n,PM_MRK_GRP_DISP,Marked group dispatched
##00002
A group containing a sampled instruction was dispatched
#282,v,g,n,n,PM_MRK_GRP_ISSUED,Marked group issued
##00015
A sampled instruction was issued.
#283,v,g,n,n,PM_MRK_IMR_RELOAD,Marked IMR reloaded
##820E2
A DL1 reload occurred due to marked load
#284,v,g,n,n,PM_MRK_L1_RELOAD_VALID,Marked L1 reload data source valid
##C70E4
The source information is valid and is for a marked load
#285,v,g,n,n,PM_MRK_LD_MISS_L1,Marked L1 D cache load misses
##82088
Marked L1 D cache load misses
#286,v,g,n,n,PM_MRK_LD_MISS_L1_LSU0,LSU0 marked L1 D cache load misses
##820E0
Load references that miss the Level 1 Data cache, by LSU0.
#287,v,g,n,n,PM_MRK_LD_MISS_L1_LSU1,LSU1 marked L1 D cache load misses
##820E4
Load references that miss the Level 1 Data cache, by LSU1.
#288,v,g,n,n,PM_MRK_LSU0_FLUSH_LRQ,LSU0 marked LRQ flushes
##810C2
A marked load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#289,u,g,n,n,PM_MRK_LSU0_FLUSH_SRQ,LSU0 marked SRQ lhs flushes
##810C3
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#290,v,g,n,n,PM_MRK_LSU0_FLUSH_ULD,LSU0 marked unaligned load flushes
##810C1
A marked load was flushed from unit 0 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#291,v,g,n,n,PM_MRK_LSU0_FLUSH_UST,LSU0 marked unaligned store flushes
##810C0
A marked store was flushed from unit 0 because it was unaligned
#292,v,g,n,n,PM_MRK_LSU1_FLUSH_LRQ,LSU1 marked LRQ flushes
##810C6
A marked load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#293,u,g,n,n,PM_MRK_LSU1_FLUSH_SRQ,LSU1 marked SRQ lhs flushes
##810C7
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#294,v,g,n,n,PM_MRK_LSU1_FLUSH_ULD,LSU1 marked unaligned load flushes
##810C4
A marked load was flushed from unit 1 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#295,u,g,n,n,PM_MRK_LSU1_FLUSH_UST,LSU1 marked unaligned store flushes
##810C5
A marked store was flushed from unit 1 because it was unaligned (crossed a 4k boundary)
#296,v,g,n,n,PM_MRK_LSU_FLUSH_ULD,Marked unaligned load flushes
##810A8
A marked load was flushed because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#297,u,g,n,n,PM_MRK_LSU_SRQ_INST_VALID,Marked instruction valid in SRQ
##C70E6
This signal is asserted every cycle when a marked request is resident in the Store Request Queue
#298,v,g,n,n,PM_MRK_STCX_FAIL,Marked STCX failed
##820E6
A marked stcx (stwcx or stdcx) failed
#299,v,g,n,n,PM_MRK_ST_CMPL,Marked store instruction completed
##00003
A sampled store has completed (data home)
#300,v,g,n,n,PM_MRK_ST_MISS_L1,Marked L1 D cache store misses
##820E3
A marked store missed the dcache
#301,v,g,n,n,PM_PMC4_OVERFLOW,PMC4 Overflow
##0000A
Overflows from PMC4 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#302,v,g,n,n,PM_PMC5_OVERFLOW,PMC5 Overflow
##0001A
Overflows from PMC5 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#303,v,g,n,n,PM_INST_CMPL,Instructions completed
##00009
Number of PowerPC instructions that completed.
#304,v,g,n,n,PM_PTEG_FROM_L2,PTEG loaded from L2
##83087
A Page Table Entry was loaded into the TLB from the local L2 due to a demand load
#305,v,g,n,n,PM_PTEG_FROM_L25_SHR,PTEG loaded from L2.5 shared
##83097
A Page Table Entry was loaded into the TLB with shared  (T or SL) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#306,v,g,n,n,PM_PTEG_FROM_L275_MOD,PTEG loaded from L2.75 modified
##830A3
A Page Table Entry was loaded into the TLB with modified (M) data from the L2 on a different module than this processor is located due to a demand load.
#307,v,g,n,n,PM_PTEG_FROM_L3,PTEG loaded from L3
##8308E
A Page Table Entry was loaded into the TLB from the local L3 due to a demand load.
#308,v,g,n,n,PM_PTEG_FROM_L35_SHR,PTEG loaded from L3.5 shared
##8309E
A Page Table Entry was loaded into the TLB with shared (S) data from the L3 of a chip on the same module as this processor is located, due to a demand load.
#309,v,g,n,n,PM_PTEG_FROM_L375_MOD,PTEG loaded from L3.75 modified
##830A7
A Page Table Entry was loaded into the TLB with modified  (M) data from the L3 of a chip on a different module than this processor is located, due to a demand load.
#310,v,g,n,n,PM_PTEG_FROM_RMEM,PTEG loaded from remote memory
##830A1
A Page Table Entry was loaded into the TLB from memory attached to a different module than this proccessor is located on.
#311,v,g,n,n,PM_PTEG_RELOAD_VALID,PTEG reload valid
##830E4
A Page Table Entry was loaded into the TLB.
#312,v,g,n,n,PM_RUN_CYC,Run cycles
##00005
Processor Cycles gated by the run latch.  Operating systems use the run latch to indicate when they are doing useful work.  The run latch is typically cleared in the OS idle loop.  Gating by the run latch filters out the idle loop.
#313,v,g,n,s,PM_SNOOP_DCLAIM_RETRY_QFULL,Snoop dclaim/flush retry due to write/dclaim queues full
##720E6
The memory controller A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#314,v,g,n,s,PM_SNOOP_PARTIAL_RTRY_QFULL,Snoop partial write retry due to partial-write queues full
##730E6
A snoop request for a partial write to memory was retried because the write queues that handle partial writes were full. When this happens the active writes are changed to high priority. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#315,v,g,n,s,PM_SNOOP_PW_RETRY_RQ,Snoop partial-write retry due to collision with active read queue
##707C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#316,v,g,n,s,PM_SNOOP_PW_RETRY_WQ_PWQ,Snoop partial-write retry due to collision with active write or partial-write queue
##717C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active write or partial write.  When this happens the snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#317,v,g,n,s,PM_SNOOP_RD_RETRY_QFULL,Snoop read retry due to read queue full
##700C6
A snoop request for a read from memory was retried because the read queues were full.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#318,v,g,n,s,PM_SNOOP_RD_RETRY_RQ,Snoop read retry due to collision with active read queue
##705C6
A snoop request for a read from memory was retried because it matched the cache line of an active read.  The snoop request is retried because the L2 may be able to source data via intervention for the 2nd read faster than the MC.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#319,v,g,n,s,PM_SNOOP_RD_RETRY_WQ,Snoop read retry due to collision with active write queue
##715C6
A snoop request for a read from memory was retried because it matched the cache line of an active write. The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#320,v,g,n,s,PM_SNOOP_RETRY_1AHEAD,Snoop retry due to one ahead collision
##725E6
Snoop retry due to one ahead collision
#321,u,g,n,s,PM_SNOOP_TLBIE,Snoop TLBIE
##800C3
A tlbie was snooped from another processor.
#322,v,g,n,s,PM_SNOOP_WR_RETRY_QFULL,Snoop read retry due to read queue full
##710C6
A snoop request for a write to memory was retried because the write queues were full.  When this happens the snoop request is retried and the writes in the write reorder queue are changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#323,v,g,n,s,PM_SNOOP_WR_RETRY_RQ,Snoop write/dclaim retry due to collision with active read queue
##706C6
A snoop request for a write or dclaim to memory was retried because it matched the cacheline of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#324,v,g,n,s,PM_SNOOP_WR_RETRY_WQ,Snoop write/dclaim retry due to collision with active write queue
##716C6
A snoop request for a write or dclaim to memory was retried because it matched the cache line of an active write.  The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#325,v,g,n,n,PM_STCX_FAIL,STCX failed
##820E1
A stcx (stwcx or stdcx) failed
#326,v,g,n,n,PM_STCX_PASS,Stcx passes
##820E5
A stcx (stwcx or stdcx) instruction was successful
#327,v,g,n,n,PM_ST_MISS_L1,L1 D cache store misses
##C10C3
A store missed the dcache.  Combined Unit 0 + 1.
#328,v,g,n,n,PM_ST_REF_L1_LSU0,LSU0 L1 D cache store references
##C10C1
Store references to the Data Cache by LSU0.
#329,v,g,n,n,PM_ST_REF_L1_LSU1,LSU1 L1 D cache store references
##C10C4
Store references to the Data Cache by LSU1.
#330,v,g,n,n,PM_SUSPENDED,Suspended
##00000
The counter is suspended (does not count).
#331,u,g,n,n,PM_TB_BIT_TRANS,Time Base bit transition
##00018
When the selected time base bit (as specified in MMCR0[TBSEL])transitions from 0 to 1
#332,v,g,n,s,PM_THRD_L2MISS_BOTH_CYC,Cycles both threads in L2 misses
##410C7
Cycles that both threads have L2 miss pending.  If only one thread has a L2 miss pending the other thread is given priority at decode.  If both threads have L2 miss pending decode priority is determined by the number of GCT entries used.
#333,v,g,n,s,PM_THRD_ONE_RUN_CYC,One of the threads in run cycles
##0000B
At least one thread has set its run latch. Operating systems use the run latch to indicate when they are doing useful work.  The run latch is typically cleared in the OS idle loop. This event does not respect FCWAIT.
#334,v,g,n,n,PM_THRD_PRIO_1_CYC,Cycles thread running at priority level 1
##420E0
Cycles this thread was running at priority level 1. Priority level 1 is the lowest and indicates the thread is sleeping.
#335,v,g,n,n,PM_THRD_PRIO_2_CYC,Cycles thread running at priority level 2
##420E1
Cycles this thread was running at priority level 2.
#336,v,g,n,n,PM_THRD_PRIO_3_CYC,Cycles thread running at priority level 3
##420E2
Cycles this thread was running at priority level 3.
#337,v,g,n,n,PM_THRD_PRIO_4_CYC,Cycles thread running at priority level 4
##420E3
Cycles this thread was running at priority level 4.
#338,v,g,n,n,PM_THRD_PRIO_5_CYC,Cycles thread running at priority level 5
##420E4
Cycles this thread was running at priority level 5.
#339,v,g,n,n,PM_THRD_PRIO_6_CYC,Cycles thread running at priority level 6
##420E5
Cycles this thread was running at priority level 6.
#340,v,g,n,n,PM_THRD_PRIO_7_CYC,Cycles thread running at priority level 7
##420E6
Cycles this thread was running at priority level 7.
#341,v,g,n,n,PM_THRD_PRIO_DIFF_0_CYC,Cycles no thread priority difference
##430E3
Cycles when this thread's priority is equal to the other thread's priority.
#342,v,g,n,n,PM_THRD_PRIO_DIFF_1or2_CYC,Cycles thread priority difference is 1 or 2
##430E4
Cycles when this thread's priority is higher than the other thread's priority by 1 or 2.
#343,v,g,n,n,PM_THRD_PRIO_DIFF_3or4_CYC,Cycles thread priority difference is 3 or 4
##430E5
Cycles when this thread's priority is higher than the other thread's priority by 3 or 4.
#344,v,g,n,n,PM_THRD_PRIO_DIFF_5or6_CYC,Cycles thread priority difference is 5 or 6
##430E6
Cycles when this thread's priority is higher than the other thread's priority by 5 or 6.
#345,v,g,n,n,PM_THRD_PRIO_DIFF_minus1or2_CYC,Cycles thread priority difference is -1 or -2
##430E2
Cycles when this thread's priority is lower than the other thread's priority by 1 or 2.
#346,v,g,n,n,PM_THRD_PRIO_DIFF_minus3or4_CYC,Cycles thread priority difference is -3 or -4
##430E1
Cycles when this thread's priority is lower than the other thread's priority by 3 or 4.
#347,v,g,n,n,PM_THRD_PRIO_DIFF_minus5or6_CYC,Cycles thread priority difference is -5 or -6
##430E0
Cycles when this thread's priority is lower than the other thread's priority by 5 or 6.
#348,v,g,n,s,PM_THRD_SEL_OVER_CLB_EMPTY,Thread selection overrides caused by CLB empty
##410C2
Thread selection was overridden because one thread's CLB was empty.
#349,v,g,n,s,PM_THRD_SEL_OVER_GCT_IMBAL,Thread selection overrides caused by GCT imbalance
##410C4
Thread selection was overridden because of a GCT imbalance.
#350,v,g,n,s,PM_THRD_SEL_OVER_ISU_HOLD,Thread selection overrides caused by ISU holds
##410C5
Thread selection was overridden because of an ISU hold.
#351,v,g,n,s,PM_THRD_SEL_OVER_L2MISS,Thread selection overrides caused by L2 misses
##410C3
Thread selection was overridden because one thread was had a L2 miss pending.
#352,v,g,n,s,PM_THRD_SEL_T0,Decode selected thread 0
##410C0
Thread selection picked thread 0 for decode.
#353,v,g,n,s,PM_THRD_SEL_T1,Decode selected thread 1
##410C1
Thread selection picked thread 1 for decode.
#354,v,g,n,s,PM_THRD_SMT_HANG,SMT hang detected
##330E7
A hung thread was detected
#355,v,g,n,n,PM_TLBIE_HELD,TLBIE held at dispatch
##130E4
Cycles a TLBIE instruction was held at dispatch.
#356,v,g,n,n,PM_TLB_MISS,TLB misses
##80088
Total of Data TLB mises + Instruction TLB misses
#357,v,g,n,s,PM_XER_MAP_FULL_CYC,Cycles XER mapper full
##100C2
The XER mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#358,v,g,n,n,PM_BR_PRED_CR,A conditional branch was predicted, CR prediction
##230E2
A conditional branch instruction was predicted as taken or not taken.
#359,v,g,n,n,PM_MEM_RQ_DISP_Q12to15,Memory read queue dispatched to queues 12-15
##732E6
A memory operation was dispatched to read queue 12,13,14 or 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#360,v,g,n,n,PM_MEM_RQ_DISP_Q16to19,Memory read queue dispatched to queues 16-19
##727E6
A memory operation was dispatched to read queue 16,17,18 or 19. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#361,v,g,n,n,PM_SNOOP_RETRY_AB_COLLISION,Snoop retry due to a b collision
##735E6
Snoop retry due to a b collision

$$$$$$$$

{ counter 2 }
#0,v,g,n,n,PM_0INST_CLB_CYC,Cycles no instructions in CLB
##400C0
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#1,v,g,n,n,PM_1INST_CLB_CYC,Cycles 1 instruction in CLB
##400C1
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#2,v,g,n,n,PM_2INST_CLB_CYC,Cycles 2 instructions in CLB
##400C2
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#3,v,g,n,n,PM_3INST_CLB_CYC,Cycles 3 instructions in CLB
##400C3
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#4,v,g,n,n,PM_4INST_CLB_CYC,Cycles 4 instructions in CLB
##400C4
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#5,v,g,n,n,PM_5INST_CLB_CYC,Cycles 5 instructions in CLB
##400C5
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#6,v,g,n,n,PM_6INST_CLB_CYC,Cycles 6 instructions in CLB
##400C6
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#7,u,g,n,s,PM_BRQ_FULL_CYC,Cycles branch queue full
##100C5
Cycles when the issue queue that feeds the branch unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#8,v,g,n,n,PM_BR_ISSUED,Branches issued
##230E4
A branch instruction was issued to the branch unit.  A branch that was incorrectly predicted may issue and execute multiple times.
#9,v,g,n,n,PM_BR_MPRED_CR,Branch mispredictions due to CR bit setting
##230E5
A conditional branch instruction was incorrectly predicted as taken or not taken.  The branch execution unit detects a branch mispredict because the CR value is opposite of the predicted value. This will result in a branch redirect flush if not overfidden by a flush of an older instruction.
#10,v,g,n,n,PM_BR_MPRED_TA,Branch mispredictions due to target address
##230E6
A branch instruction target was incorrectly predicted. This will result in a branch mispredict flush unless a flush is detected from an older instruction.
#11,v,g,n,n,PM_BR_PRED_TA,A conditional branch was predicted, target prediction
##23087,230E3
The target address of a branch instruction was predicted.
#12,v,g,n,s,PM_CLB_EMPTY_CYC,Cycles CLB empty
##410C6
Cycles when both thread's CLB is completely empty.
#13,v,g,n,n,PM_CLB_FULL_CYC,Cycles CLB full
##220E5
Cycles when both thread's CLB is full.
#14,v,g,n,n,PM_CMPLU_STALL_DCACHE_MISS,Completion stall caused by D cache miss
##1109A
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes suffered a Data Cache Miss. Data Cache Miss has higher priority than any other Load/Store delay, so if an instruction encounters multiple delays only the Data Cache Miss will be reported and the entire delay period will be charged to Data Cache Miss. This is a subset of PM_CMPLU_STALL_LSU.
#15,v,g,n,n,PM_CMPLU_STALL_FDIV,Completion stall caused by FDIV or FQRT instruction
##1109B
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes was a floating point divide or square root instruction. This is a subset of PM_CMPLU_STALL_FPU.
#16,v,g,n,n,PM_CMPLU_STALL_FXU,Completion stall caused by FXU instruction
##11099
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes was a fixed point instruction.
#17,v,g,n,n,PM_CMPLU_STALL_LSU,Completion stall caused by LSU instruction
##11098
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes was a load/store instruction.
#18,u,g,n,s,PM_CRQ_FULL_CYC,Cycles CR issue queue full
##110C1
The issue queue that feeds the Conditional Register unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#19,v,g,n,s,PM_CR_MAP_FULL_CYC,Cycles CR logical operation mapper full
##100C4
The Conditional Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#20,v,g,n,s,PM_CYC,Processor cycles
##0000F
Processor cycles
#21,v,g,n,n,PM_DATA_FROM_L25_MOD,Data loaded from L2.5 modified
##C3097
The processor's Data Cache was reloaded with modified (M) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#22,v,g,n,n,PM_DATA_FROM_L35_MOD,Data loaded from L3.5 modified
##C309E
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a demand load.
#23,v,g,n,n,PM_DATA_FROM_LMEM,Data loaded from local memory
##C3087
The processor's Data Cache was reloaded from memory attached to the same module this proccessor is located on.
#24,v,g,n,n,PM_DATA_TABLEWALK_CYC,Cycles doing data tablewalks
##800C7
Cycles a translation tablewalk is active.  While a tablewalk is active any request attempting to access the TLB will be rejected and retried.
#25,u,g,n,s,PM_DC_INV_L2,L1 D cache entries invalidated from L2
##C10C7
A dcache invalidated was received from the L2 because a line in L2 was castout.
#26,v,g,n,n,PM_DC_PREF_OUT_OF_STREAMS,D cache out of prefetch streams
##C50C2
A new prefetch stream was detected but no more stream entries were available.
#27,v,g,n,n,PM_DC_PREF_DST,DST (Data Stream Touch) stream start
##830E6
A prefetch stream was started using the DST instruction.
#28,v,g,n,n,PM_DC_PREF_STREAM_ALLOC,D cache new prefetch stream allocated
##830E7
A new Prefetch Stream was allocated.
#29,v,g,n,n,PM_DSLB_MISS,Data SLB misses
##800C5
A SLB miss for a data request occurred. SLB misses trap to the operating system to resolve.
#30,v,g,n,n,PM_DTLB_MISS,Data TLB misses
##800C4,C20E0
Data TLB misses, all page sizes.
#31,v,g,n,n,PM_DTLB_MISS_64K,Data TLB miss for 64K page
##C208D
Data TLB references to 64KB pages that missed the TLB. Page size is determined at TLB reload time.
#32,v,g,n,n,PM_DTLB_REF,Data TLB references
##C20E4
Total number of Data TLB references for all page sizes. Page size is determined at TLB reload time.
#33,v,g,n,n,PM_DTLB_REF_64K,Data TLB reference for 64K page
##C2086
Data TLB references for 64KB pages. Includes hits + misses.
#34,v,g,n,n,PM_EE_OFF,Cycles MSR(EE) bit off
##130E3
Cycles MSR(EE) bit was off indicating that interrupts due to external exceptions were masked.
#35,u,g,n,n,PM_EE_OFF_EXT_INT,Cycles MSR(EE) bit off and external interrupt pending
##130E7
Cycles when an interrupt due to an external exception is pending but external exceptions were masked.
#36,v,g,n,s,PM_FAB_CMD_ISSUED,Fabric command issued
##700C7
Incremented when a chip issues a command on its SnoopA address bus. Each of the two address busses (SnoopA and SnoopB) is capable of one transaction per fabric cycle (one fabric cycle = 2 cpu cycles in normal 2:1 mode), but each chip can only drive the SnoopA bus, and can only drive one transaction every two fabric cycles (i.e., every four cpu cycles). In MCM-based systems, two chips interleave their accesses to each of the two fabric busses (SnoopA, SnoopB) to reach a peak capability of one transaction per cpu clock cycle. The two chips that drive SnoopB are wired so that the chips refer to the bus as SnoopA but it is connected to the other two chips as SnoopB.  Note that this event will only be recorded by the FBC on the chip that sourced the operation. The signal is delivered at FBC speed and the count must be scaled.
#37,v,g,n,n,PM_FAB_CMD_RETRIED,Fabric command retried
##710C7
Incremented when a command issued by a chip on its SnoopA address bus is retried for any reason. The overwhelming majority of retries are due to running out of memory controller queues but retries can also be caused by trying to reference addresses that are in a transient cache state -- e.g. a line is transient after issuing a DCLAIM instruction to a shared line but before the associated store completes.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#38,v,g,n,s,PM_FAB_DCLAIM_ISSUED,dclaim issued
##720E7
A DCLAIM command was issued. Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#39,v,g,n,s,PM_FAB_DCLAIM_RETRIED,dclaim retried
##730E7
A DCLAIM command was retried.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#40,v,g,n,s,PM_FAB_HOLDtoNN_EMPTY,Hold buffer to NN empty
##722E7
Fabric cyles when the Next Node out hold-buffers are emtpy.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#41,v,g,n,s,PM_FAB_HOLDtoVN_EMPTY,Hold buffer to VN empty
##721E7
Fabric cycles when the Vertical Node out hold-buffers are emtpy. The signal is delivered at FBC speed and the count must be scaled accordingly.
#42,v,g,n,s,PM_FAB_M1toP1_SIDECAR_EMPTY,M1 to P1 sidecar empty
##702C7
Fabric cycles when the Minus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#43,v,g,n,s,PM_FAB_M1toVNorNN_SIDECAR_EMPTY,M1 to VN/NN sidecar empty
##712C7
Fabric cycles when the Minus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#44,v,g,n,s,PM_FAB_P1toM1_SIDECAR_EMPTY,P1 to M1 sidecar empty
##701C7
Fabric cycles when the Plus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#45,v,g,n,s,PM_FAB_P1toVNorNN_SIDECAR_EMPTY,P1 to VN/NN sidecar empty
##711C7
Fabric cycles when the Plus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#46,v,g,n,s,PM_FAB_PNtoNN_DIRECT,PN to NN beat went straight to its destination
##703C7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound NN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled.
#47,v,g,n,s,PM_FAB_PNtoNN_SIDECAR,PN to NN beat went to sidecar first
##713C7
Fabric Data beats that the base chip takes the inbound PN data and forwards it on to the outbound NN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled.
#48,v,g,n,s,PM_FAB_PNtoVN_DIRECT,PN to VN beat went straight to its destination
##723E7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound VN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled accordingly.
#49,v,g,n,s,PM_FAB_PNtoVN_SIDECAR,PN to VN beat went to sidecar first
##733E7
Fabric data beats that the base chip takes the inbound PN data and forwards it on to the outbound VN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled accordingly.
#50,v,g,n,s,PM_FAB_VBYPASS_EMPTY,Vertical bypass buffer empty
##731E7
Fabric cycles when the Middle Bypass sidecar is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#51,v,g,n,n,PM_FLUSH,Flushes
##110C7
Flushes occurred including LSU and Branch flushes.
#52,v,g,n,n,PM_FLUSH_BR_MPRED,Flush caused by branch mispredict
##110C6
A flush was caused by a branch mispredict.
#53,v,g,n,s,PM_FLUSH_IMBAL,Flush caused by thread GCT imbalance
##330E3
This thread has been flushed at dispatch because it is stalled and a GCT imbalance exists.  GCT thresholds are set in the TSCR register. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#54,v,g,n,s,PM_FLUSH_SB,Flush caused by scoreboard operation
##330E2
This thread has been flushed at dispatch because its scoreboard bit is set indicating that a non-renamed resource is being updated. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#55,v,g,n,s,PM_FLUSH_SYNC,Flush caused by sync
##330E1
This thread has been flushed at dispatch due to a sync, lwsync, ptesync, or tlbsync instruction.  This allows the other thread to have more machine resources for it to make progress until the sync finishes.
#56,v,g,n,s,PM_FPR_MAP_FULL_CYC,Cycles FPR mapper full
##100C1
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#57,v,g,n,n,PM_FPU0_1FLOP,FPU0 executed add, mult, sub, cmp or sel instruction
##000C3
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#58,v,g,n,n,PM_FPU0_DENORM,FPU0 received denormalized data
##020E0
FPU0 has encountered a denormalized operand.
#59,v,g,n,n,PM_FPU0_FDIV,FPU0 executed FDIV instruction
##000C0
FPU0 has executed a divide instruction. This could be fdiv, fdivs, fdiv. fdivs.
#60,v,g,n,n,PM_FPU0_FEST,FPU0 executed FEST instruction
##010C2
FPU0 has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#61,v,g,n,n,PM_FPU0_FIN,FPU0 produced a result
##010C3
FPU0 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads.
#62,v,g,n,n,PM_FPU0_FMA,FPU0 executed multiply-add instruction
##000C1
The floating point unit has executed a multiply-add kind of instruction.  This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#63,v,g,n,n,PM_FPU0_FMOV_FEST,FPU0 executed FMOV or FEST instructions
##010C0
FPU0 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#64,v,g,n,n,PM_FPU0_FPSCR,FPU0 executed FPSCR instruction
##030E0
FPU0 has executed FPSCR move related instruction. This could be mtfsfi*, mtfsb0*, mtfsb1*, mffs*, mtfsf*, mcrsf* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#65,v,g,n,n,PM_FPU0_FRSP_FCONV,FPU0 executed FRSP or FCONV instructions
##010C1
FPU0 has executed a frsp or convert kind of instruction. This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#66,v,g,n,n,PM_FPU0_FSQRT,FPU0 executed FSQRT instruction
##000C2
FPU0 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#67,v,g,n,s,PM_FPU0_FULL_CYC,Cycles FPU0 issue queue full
##100C3
The issue queue for FPU0 cannot accept any more instruction. Dispatch to this issue queue is stopped.
#68,v,g,n,n,PM_FPU0_SINGLE,FPU0 executed single precision instruction
##020E3
FPU0 has executed a single precision instruction.
#69,v,g,n,n,PM_FPU0_STALL3,FPU0 stalled in pipe3
##020E1
FPU0 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#70,v,g,n,n,PM_FPU0_STF,FPU0 executed store instruction
##020E2
FPU0 has executed a Floating Point Store instruction.
#71,v,g,n,n,PM_FPU1_1FLOP,FPU1 executed add, mult, sub, cmp or sel instruction
##000C7
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#72,v,g,n,n,PM_FPU1_DENORM,FPU1 received denormalized data
##020E4
FPU1 has encountered a denormalized operand.
#73,v,g,n,n,PM_FPU1_FDIV,FPU1 executed FDIV instruction
##000C4
FPU1 has executed a divide instruction.  This could be fdiv, fdivs, fdiv. fdivs.
#74,v,g,n,n,PM_FPU1_FEST,FPU1 executed FEST instruction
##010C6
FPU1 has executed an estimate instructions.  This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#75,v,g,n,n,PM_FPU1_FIN,FPU1 produced a result
##010C7
FPU1 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads., ,
#76,v,g,n,n,PM_FPU1_FMA,FPU1 executed multiply-add instruction
##000C5
The floating point unit has executed a multiply-add kind of instruction. This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#77,v,g,n,n,PM_FPU1_FMOV_FEST,FPU1 executed FMOV or FEST instructions
##010C4
FPU1 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#78,v,g,n,n,PM_FPU1_FRSP_FCONV,FPU1 executed FRSP or FCONV instructions
##010C5
FPU1 has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#79,v,g,n,n,PM_FPU1_FSQRT,FPU1 executed FSQRT instruction
##000C6
FPU1 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#80,v,g,n,s,PM_FPU1_FULL_CYC,Cycles FPU1 issue queue full
##100C7
The issue queue for FPU1 cannot accept any more instructions. Dispatch to this issue queue is stopped
#81,v,g,n,n,PM_FPU1_SINGLE,FPU1 executed single precision instruction
##020E7
FPU1 has executed a single precision instruction.
#82,v,g,n,n,PM_FPU1_STALL3,FPU1 stalled in pipe3
##020E5
FPU1 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#83,v,g,n,n,PM_FPU1_STF,FPU1 executed store instruction
##020E6
FPU1 has executed a Floating Point Store instruction.
#84,v,g,n,n,PM_FPU_FMA,FPU executed multiply-add instruction
##00088
This signal is active for one cycle when FPU is executing multiply-add kind of instruction. This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs. Combined Unit 0 + Unit 1.
#85,v,g,n,n,PM_FPU_FRSP_FCONV,FPU executed FRSP or FCONV instructions
##010A8
The floating point unit has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs. Combined Unit 0 + Unit 1.
#86,v,g,n,n,PM_FPU_FSQRT,FPU executed FSQRT instruction
##00090
The floating point unit has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs. Combined Unit 0 + Unit 1.
#87,v,g,n,n,PM_FPU_STALL3,FPU stalled in pipe3
##02088
FPU has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always). This signal is active during the entire duration of the stall. Combined Unit 0 + Unit 1.
#88,v,g,n,n,PM_FPU_STF,FPU executed store instruction
##02090
FPU has executed a store instruction. Combined Unit 0 + Unit 1.
#89,v,g,n,s,PM_FXLS0_FULL_CYC,Cycles FXU0/LS0 queue full
##110C0
The issue queue that feeds the Fixed Point unit 0 / Load Store Unit 0 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#90,v,g,n,s,PM_FXLS1_FULL_CYC,Cycles FXU1/LS1 queue full
##110C4
The issue queue that feeds the Fixed Point unit 1 / Load Store Unit 1 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#91,v,g,n,n,PM_FXU0_FIN,FXU0 produced a result
##130E2
The Fixed Point unit 0 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#92,v,g,n,n,PM_FXU1_FIN,FXU1 produced a result
##130E6
The Fixed Point unit 1 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#93,u,g,n,n,PM_FXU_BUSY,FXU busy
##00012
Cycles when both FXU0 and FXU1 are busy.
#94,v,g,n,n,PM_MRK_FXU_FIN,Marked instruction FXU processing finished
##00014
One of the Fixed Point Units finished a marked instruction.  Instructions that finish may not necessary complete.
#95,v,g,n,s,PM_GCT_EMPTY_CYC,Cycles GCT empty
##00004
The Global Completion Table is completely empty
#96,v,g,n,n,PM_GCT_FULL_CYC,Cycles GCT full
##100C0
The Global Completion Table is completely full.
#97,v,g,n,n,PM_GCT_NOSLOT_IC_MISS,No slot in GCT caused by I cache miss
##1009C
Cycles when the Global Completion Table has no slots from this thread because of an Instruction Cache miss.
#98,v,g,n,s,PM_GCT_USAGE_60to79_CYC,Cycles GCT 60-79% full
##0001F
Cycles when the Global Completion Table has between 60% and 70% of its slots used.  The GCT has 20 entries shared between threads.
#99,v,g,n,s,PM_GPR_MAP_FULL_CYC,Cycles GPR mapper full
##130E5
The General Purpose Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#100,v,g,n,n,PM_GRP_BR_REDIR,Group experienced branch redirect
##120E6
Number of groups, counted at dispatch, that have encountered a branch redirect.  Every group constructed from a fetch group that has been redirected will count.
#101,c,g,n,n,PM_GRP_IC_MISS_BR_REDIR_NONSPEC,Group experienced non-speculative I cache miss or branch redirect
##120E5
Group experienced non-speculative I cache miss or branch redirect
#102,v,g,n,n,PM_GRP_DISP,Group dispatches
##00002
A group was dispatched
#103,v,g,n,n,PM_GRP_DISP_BLK_SB_CYC,Cycles group dispatch blocked by scoreboard
##130E1
A scoreboard operation on a non-renamed resource has blocked dispatch.
#104,v,g,n,n,PM_GRP_DISP_REJECT,Group dispatch rejected
##120E4
A group that previously attempted dispatch was rejected.
#105,v,g,n,n,PM_GRP_DISP_VALID,Group dispatch valid
##120E3
A group is available for dispatch.  This does not mean it was successfully dispatched.
#106,v,g,n,n,PM_GRP_IC_MISS,Group experienced I cache miss
##120E7
Number of groups, counted at dispatch, that have encountered an icache miss redirect.  Every group constructed from a fetch group that missed the instruction cache will count.
#107,v,g,n,n,PM_HV_CYC,Hypervisor Cycles
##0000B
Cycles when the processor is executing in Hypervisor (MSR[HV] = 1 and MSR[PR]=0)
#108,v,g,n,n,PM_IC_DEMAND_L2_BHT_REDIRECT,L2 I cache demand request due to BHT redirect
##230E0
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (CR mispredict).
#109,v,g,n,n,PM_IC_DEMAND_L2_BR_REDIRECT,L2 I cache demand request due to branch redirect
##230E1
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (either ALL mispredicted or Target).
#110,v,g,n,n,PM_IC_PREF_REQ,Instruction prefetch requests
##220E6
An instruction prefetch request has been made.
#111,v,g,n,n,PM_IERAT_XLATE_WR,Translation written to ierat
##220E7
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#112,v,g,n,n,PM_IERAT_XLATE_WR_LP,Large page translation written to ierat
##210C6
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#113,v,g,n,n,PM_IOPS_CMPL,Internal operations completed
##00001
Number of internal operations that completed.
#114,v,g,n,n,PM_INST_DISP_ATTEMPT,Instructions dispatch attempted
##120E1
Number of PowerPC Instructions dispatched (attempted, not filtered by success.
#115,v,g,n,n,PM_INST_FETCH_CYC,Cycles at least 1 instruction fetched
##220E4
Cycles when at least one instruction was sent from the fetch unit to the decode unit.
#116,v,g,n,n,PM_INST_FROM_L1,Instruction fetched from L1
##2208D
An instruction fetch group was fetched from L1. Fetch Groups can contain up to 8 instructions
#117,v,g,n,n,PM_INST_FROM_L25_MOD,Instruction fetched from L2.5 modified
##22096
An instruction fetch group was fetched with modified (M) data from the L2 of a chip on the same module as this processor is located.  Fetch groups can contain up to 8 instructions.
#118,v,g,n,n,PM_INST_FROM_L35_MOD,Instruction fetched from L3.5 modified
##2209D
An instruction fetch group was fetched with modified (M) data from the L3 of a chip on the same module as this processor is located. Fetch groups can contain up to 8 instructions
#119,v,g,n,n,PM_INST_FROM_LMEM,Instruction fetched from local memory
##22086
An instruction fetch group was fetched from memory attached to the same module this proccessor is located on.  Fetch groups can contain up to 8 instructions
#120,u,g,n,n,PM_ISLB_MISS,Instruction SLB misses
##800C1
A SLB miss for an instruction fetch as occurred
#121,v,g,n,n,PM_ITLB_MISS,Instruction TLB misses
##800C0
A TLB miss for an Instruction Fetch has occurred
#122,v,g,n,n,PM_L1_DCACHE_RELOAD_VALID,L1 reload data source valid
##C30E4
The data source information is valid,the data cache has been reloaded.  Prior to POWER5+ this included data cache reloads due to prefetch activity.  With POWER5+ this now only includes reloads due to demand loads.
#123,v,g,n,n,PM_L1_PREF,L1 cache data prefetches
##C70E7
A request to prefetch data into the L1 was made
#124,v,g,n,n,PM_L1_WRITE_CYC,Cycles writing to instruction L1
##230E7
Cycles that a cache line was written to the instruction cache.
#125,v,g,n,s,PM_L2SA_MOD_INV,L2 slice A transition from modified to invalid
##730E0
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#126,v,g,n,s,PM_L2SA_MOD_TAG,L2 slice A transition from modified to tagged
##720E0
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#127,v,g,n,s,PM_L2SA_RCLD_DISP,L2 slice A RC load dispatch attempt
##701C0
A Read/Claim dispatch for a Load was attempted
#128,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_ADDR,L2 slice A RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C0
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#129,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_OTHER,L2 slice A RC load dispatch attempt failed due to other reasons
##731E0
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#130,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_RC_FULL,L2 slice A RC load dispatch attempt failed due to all RC full
##721E0
A Read/Claim dispatch for a load failed because all RC machines are busy.
#131,v,g,n,s,PM_L2SA_RCST_DISP,L2 slice A RC store dispatch attempt
##702C0
A Read/Claim dispatch for a Store was attempted.
#132,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_ADDR,L2 slice A RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C0
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#133,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_OTHER,L2 slice A RC store dispatch attempt failed due to other reasons
##732E0
A Read/Claim dispatch for a store failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#134,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_RC_FULL,L2 slice A RC store dispatch attempt failed due to all RC full
##722E0
A Read/Claim dispatch for a store failed because all RC machines are busy.
#135,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY,L2 slice A RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C0
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#136,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice A RC dispatch attempt failed due to all CO busy
##713C0
A Read/Claim dispatch was rejected because all Castout machines were busy.
#137,v,g,n,s,PM_L2SA_SHR_INV,L2 slice A transition from shared to invalid
##710C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#138,v,g,n,s,PM_L2SA_SHR_MOD,L2 slice A transition from shared to modified
##700C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#139,v,g,n,n,PM_L2SA_ST_HIT,L2 slice A store hits
##733E0
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B, and C.
#140,v,g,n,n,PM_L2SA_ST_REQ,L2 slice A store requests
##723E0
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#141,v,g,n,s,PM_L2SB_MOD_INV,L2 slice B transition from modified to invalid
##730E1
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#142,v,g,n,s,PM_L2SB_MOD_TAG,L2 slice B transition from modified to tagged
##720E1
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#143,v,g,n,s,PM_L2SB_RCLD_DISP,L2 slice B RC load dispatch attempt
##701C1
A Read/Claim dispatch for a Load was attempted
#144,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_ADDR,L2 slice B RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C1
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#145,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_OTHER,L2 slice B RC load dispatch attempt failed due to other reasons
##731E1
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#146,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_RC_FULL,L2 slice B RC load dispatch attempt failed due to all RC full
##721E1
A Read/Claim dispatch for a load failed because all RC machines are busy.
#147,v,g,n,s,PM_L2SB_RCST_DISP,L2 slice B RC store dispatch attempt
##702C1
A Read/Claim dispatch for a Store was attempted.
#148,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_ADDR,L2 slice B RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C1
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#149,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_OTHER,L2 slice B RC store dispatch attempt failed due to other reasons
##732E1
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#150,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_RC_FULL,L2 slice B RC store dispatch attempt failed due to all RC full
##722E2
A Read/Claim dispatch for a store failed because all RC machines are busy.
#151,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY,L2 slice B RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C1
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#152,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice B RC dispatch attempt failed due to all CO busy
##713C1
A Read/Claim dispatch was rejected because all Castout machines were busy.
#153,v,g,n,s,PM_L2SB_SHR_INV,L2 slice B transition from shared to invalid
##710C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#154,v,g,n,s,PM_L2SB_SHR_MOD,L2 slice B transition from shared to modified
##700C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#155,v,g,n,n,PM_L2SB_ST_HIT,L2 slice B store hits
##733E1
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B and C.
#156,v,g,n,n,PM_L2SB_ST_REQ,L2 slice B store requests
##723E1
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#157,v,g,n,s,PM_L2SC_MOD_INV,L2 slice C transition from modified to invalid
##730E2
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#158,v,g,n,s,PM_L2SC_MOD_TAG,L2 slice C transition from modified to tagged
##720E2
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#159,v,g,n,s,PM_L2SC_RCLD_DISP,L2 slice C RC load dispatch attempt
##701C2
A Read/Claim dispatch for a Load was attempted
#160,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_ADDR,L2 slice C RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C2
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#161,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_OTHER,L2 slice C RC load dispatch attempt failed due to other reasons
##731E2
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#162,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_RC_FULL,L2 slice C RC load dispatch attempt failed due to all RC full
##721E2
A Read/Claim dispatch for a load failed because all RC machines are busy.
#163,v,g,n,s,PM_L2SC_RCST_DISP,L2 slice C RC store dispatch attempt
##702C2
A Read/Claim dispatch for a Store was attempted.
#164,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_ADDR,L2 slice C RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C2
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#165,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_OTHER,L2 slice C RC store dispatch attempt failed due to other reasons
##732E2
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#166,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_RC_FULL,L2 slice C RC store dispatch attempt failed due to all RC full
##722E1
A Read/Claim dispatch for a store failed because all RC machines are busy.
#167,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY,L2 slice C RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C2
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#168,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice C RC dispatch attempt failed due to all CO busy
##713C2
A Read/Claim dispatch was rejected because all Castout machines were busy.
#169,v,g,n,s,PM_L2SC_SHR_INV,L2 slice C transition from shared to invalid
##710C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#170,v,g,n,s,PM_L2SC_SHR_MOD,L2 slice C transition from shared to modified
##700C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#171,v,g,n,n,PM_L2SC_ST_HIT,L2 slice C store hits
##733E2
A store request made from the core hit in the L2 directory.  The event is provided on each of the  three slices A, B, and C.
#172,v,g,n,n,PM_L2SC_ST_REQ,L2 slice C store requests
##723E2
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#173,v,g,n,n,PM_L2_PREF,L2 cache prefetches
##C50C3
A request to prefetch data into L2 was made
#174,v,g,n,s,PM_L3SA_ALL_BUSY,L3 slice A active for every cycle all CI/CO machines busy
##721E3
Cycles All Castin/Castout machines are busy.
#175,v,g,n,s,PM_L3SA_HIT,L3 slice A hits
##711C3
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#176,v,g,n,s,PM_L3SA_MOD_INV,L3 slice A transition from modified to invalid
##730E3
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#177,v,g,n,s,PM_L3SA_MOD_TAG,L3 slice A transition from modified to TAG
##720E3
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case) Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#178,v,g,n,s,PM_L3SA_REF,L3 slice A references
##701C3
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#179,v,g,n,s,PM_L3SA_SHR_INV,L3 slice A transition from shared to invalid
##710C3
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#180,v,g,n,s,PM_L3SA_SNOOP_RETRY,L3 slice A snoop retries
##731E3
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#181,v,g,n,s,PM_L3SB_ALL_BUSY,L3 slice B active for every cycle all CI/CO machines busy
##721E4
Cycles All Castin/Castout machines are busy.
#182,v,g,n,s,PM_L3SB_HIT,L3 slice B hits
##711C4
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#183,v,g,n,s,PM_L3SB_MOD_INV,L3 slice B transition from modified to invalid
##730E4
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I).  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#184,v,g,n,s,PM_L3SB_MOD_TAG,L3 slice B transition from modified to TAG
##720E4
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#185,v,g,n,s,PM_L3SB_REF,L3 slice B references
##701C4
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#186,v,g,n,s,PM_L3SB_SHR_INV,L3 slice B transition from shared to invalid
##710C4
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#187,v,g,n,s,PM_L3SB_SNOOP_RETRY,L3 slice B snoop retries
##731E4
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#188,v,g,n,s,PM_L3SC_ALL_BUSY,L3 slice C active for every cycle all CI/CO machines busy
##721E5
Cycles All Castin/Castout machines are busy.
#189,v,g,n,s,PM_L3SC_HIT,L3 slice C hits
##711C5
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 Slice
#190,v,g,n,s,PM_L3SC_MOD_INV,L3 slice C transition from modified to invalid
##730E5
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a previous read op Tx is not included since it is considered shared at this point.
#191,v,g,n,s,PM_L3SC_MOD_TAG,L3 slice C transition from modified to TAG
##720E5
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#192,v,g,n,s,PM_L3SC_REF,L3 slice C references
##701C5
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice.
#193,v,g,n,s,PM_L3SC_SHR_INV,L3 slice C transition from shared to invalid
##710C5
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#194,v,g,n,s,PM_L3SC_SNOOP_RETRY,L3 slice C snoop retries
##731E5
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#195,v,g,n,n,PM_LARX_LSU0,Larx executed on LSU0
##820E7
A larx (lwarx or ldarx) was executed on side 0 (there is no corresponding unit 1 event since larx instructions can only execute on unit 0)
#196,v,g,n,n,PM_LD_MISS_L1_LSU0,LSU0 L1 D cache load misses
##C10C2
Load references that miss the Level 1 Data cache, by unit 0.
#197,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C5
Load references that miss the Level 1 Data cache, by unit 1.
#198,v,g,n,n,PM_LD_REF_L1_LSU0,LSU0 L1 D cache load references
##C10C0
Load references to Level 1 Data Cache, by unit 0.
#199,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C6
Load references that miss the Level 1 Data cache, by unit 1.
#200,u,g,n,s,PM_LR_CTR_MAP_FULL_CYC,Cycles LR/CTR mapper full
##100C6
The LR/CTR mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#201,v,g,n,n,PM_LSU0_BUSY_REJECT,LSU0 busy due to reject
##C20E1
Total cycles the Load Store Unit 0 is busy rejecting instructions.
#202,v,g,n,n,PM_LSU0_DERAT_MISS,LSU0 DERAT misses
##800C2
Total D-ERAT Misses by LSU0.   Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.
#203,v,g,n,n,PM_LSU0_FLUSH_LRQ,LSU0 LRQ flushes
##C00C2
A load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#204,u,g,n,n,PM_LSU0_FLUSH_SRQ,LSU0 SRQ lhs flushes
##C00C3
A store was flushed by unit 0 because younger load hits and older store that is already in the SRQ or in the same group.
#205,v,g,n,n,PM_LSU0_FLUSH_ULD,LSU0 unaligned load flushes
##C00C0
A load was flushed from unit 0 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1)
#206,v,g,n,n,PM_LSU0_FLUSH_UST,LSU0 unaligned store flushes
##C00C1
A store was flushed from unit 0 because it was unaligned (crossed a 4K boundary).
#207,v,g,n,n,PM_LSU0_LDF,LSU0 executed Floating Point load instruction
##C50C0
A floating point load was executed by LSU0
#208,v,g,n,n,PM_LSU0_NCLD,LSU0 non-cacheable loads
##C50C1
A non-cacheable load was executed by unit 0.
#209,v,g,n,n,PM_LSU0_REJECT_ERAT_MISS,LSU0 reject due to ERAT miss
##C40C3
Total cycles the Load Store Unit 0 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#210,v,g,n,n,PM_LSU0_REJECT_LMQ_FULL,LSU0 reject due to LMQ full or missed data coming
##C40C1
Total cycles the Load Store Unit 0 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#211,v,g,n,n,PM_LSU0_REJECT_RELOAD_CDF,LSU0 reject due to reload CDF or tag update collision
##C40C2
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#212,v,g,n,n,PM_LSU0_REJECT_SRQ,LSU0 SRQ lhs rejects
##C40C0
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#213,u,g,n,n,PM_LSU0_SRQ_STFWD,LSU0 SRQ store forwarded
##C60E1
Data from a store instruction was forwarded to a load on unit 0.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#214,v,g,n,n,PM_LSU1_BUSY_REJECT,LSU1 busy due to reject
##C20E5
Total cycles the Load Store Unit 1 is busy rejecting instructions.
#215,v,g,n,n,PM_LSU1_DERAT_MISS,LSU1 DERAT misses
##800C6
A data request (load or store) from LSU Unit 1 missed the ERAT and resulted in an ERAT reload. Multiple instructions may miss the ERAT entry for the same 4K page, but only one reload will occur.
#216,v,g,n,n,PM_LSU1_FLUSH_LRQ,LSU1 LRQ flushes
##C00C6
A load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#217,u,g,n,n,PM_LSU1_FLUSH_SRQ,LSU1 SRQ lhs flushes
##C00C7
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#218,v,g,n,n,PM_LSU1_FLUSH_ULD,LSU1 unaligned load flushes
##C00C4
A load was flushed from unit 1 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1).
#219,u,g,n,n,PM_LSU1_FLUSH_UST,LSU1 unaligned store flushes
##C00C5
A store was flushed from unit 1 because it was unaligned (crossed a 4K boundary)
#220,v,g,n,n,PM_LSU1_LDF,LSU1 executed Floating Point load instruction
##C50C4
A floating point load was executed by LSU1
#221,v,g,n,n,PM_LSU1_NCLD,LSU1 non-cacheable loads
##C50C5
A non-cacheable load was executed by Unit 0.
#222,v,g,n,n,PM_LSU1_REJECT_ERAT_MISS,LSU1 reject due to ERAT miss
##C40C7
Total cycles the Load Store Unit 1 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#223,v,g,n,n,PM_LSU1_REJECT_LMQ_FULL,LSU1 reject due to LMQ full or missed data coming
##C40C5
Total cycles the Load Store Unit 1 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#224,v,g,n,n,PM_LSU1_REJECT_RELOAD_CDF,LSU1 reject due to reload CDF or tag update collision
##C40C6
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#225,v,g,n,n,PM_LSU1_REJECT_SRQ,LSU1 SRQ lhs rejects
##C40C4
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#226,u,g,n,n,PM_LSU1_SRQ_STFWD,LSU1 SRQ store forwarded
##C60E5
Data from a store instruction was forwarded to a load on unit 1.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#227,v,g,n,n,PM_LSU_BUSY_REJECT,LSU busy due to reject
##C2088
Total cycles the Load Store Unit is busy rejecting instructions. Combined unit 0 + 1.
#228,v,g,n,n,PM_LSU_DERAT_MISS,DERAT misses
##80090
Total D-ERAT Misses.  Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.  Combined Unit 0 + 1.
#229,v,g,n,n,PM_LSU_FLUSH,Flush initiated by LSU
##110C5
A flush was initiated by the Load Store Unit
#230,v,g,n,n,PM_LSU_FLUSH_LRQ,LRQ flushes
##C0090
A load was flushed because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.  Combined Units 0 and 1.
#231,v,g,n,s,PM_LSU_FLUSH_LRQ_FULL,Flush caused by LRQ full
##320E7
This thread was flushed at dispatch because its Load Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#232,v,g,n,s,PM_LSU_FLUSH_SRQ_FULL,Flush caused by SRQ full
##330E0
This thread was flushed at dispatch because its Store Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#233,v,g,n,n,PM_LSU_FLUSH_UST,SRQ unaligned store flushes
##C0088
A store was flushed because it was unaligned (crossed a 4K boundary).  Combined Unit 0 + 1.
#234,u,g,n,s,PM_LSU_LMQ_FULL_CYC,Cycles LMQ full
##C30E7
The Load Miss Queue was full.
#235,v,g,n,n,PM_LSU_LMQ_LHR_MERGE,LMQ LHR merges
##C70E5
A data cache miss occurred for the same real cache line address as an earlier request already in the Load Miss Queue and was merged into the LMQ entry.
#236,v,g,n,s,PM_LSU_LMQ_S0_ALLOC,LMQ slot 0 allocated
##C30E6
The first entry in the LMQ was allocated.
#237,v,g,n,n,PM_LSU_LMQ_S0_VALID,LMQ slot 0 valid
##C30E5
This signal is asserted every cycle when the first entry in the LMQ is valid. The LMQ had eight entries that are allocated FIFO
#238,u,g,n,n,PM_LSU_LMQ_SRQ_EMPTY_CYC,Cycles LMQ and SRQ empty
##00015
Cycles when both the LMQ and SRQ are empty (LSU is idle)
#239,v,g,n,s,PM_LSU_LRQ_FULL_CYC,Cycles LRQ full
##110C2
Cycles when the LRQ is full.
#240,v,g,n,n,PM_LSU_LRQ_S0_ALLOC,LRQ slot 0 allocated
##C60E7
LRQ slot zero was allocated
#241,v,g,n,n,PM_LSU_LRQ_S0_VALID,LRQ slot 0 valid
##C60E6
This signal is asserted every cycle that the Load Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the LRQ is split between the two threads (16 entries each).
#242,v,g,n,n,PM_LSU_REJECT_LMQ_FULL,LSU reject due to LMQ full or missed data coming
##C4088
Total cycles the Load Store Unit is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all the eight entries are full, subsequent load instructions are rejected. Combined unit 0 + 1.
#243,v,g,n,n,PM_LSU_REJECT_RELOAD_CDF,LSU reject due to reload CDF or tag update collision
##C4090
Total cycles the Load Store Unit is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.  Combined Unit 0 + 1.
#244,v,g,n,s,PM_LSU_SRQ_FULL_CYC,Cycles SRQ full
##110C3
Cycles the Store Request Queue is full.
#245,v,g,n,n,PM_LSU_SRQ_S0_ALLOC,SRQ slot 0 allocated
##C20E7
SRQ Slot zero was allocated
#246,v,g,n,n,PM_LSU_SRQ_S0_VALID,SRQ slot 0 valid
##C20E6
This signal is asserted every cycle that the Store Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the SRQ is split between the two threads (16 entries each).
#247,c,g,n,n,PM_LSU_SRQ_STFWD,SRQ store forwarded
##C6088
Data from a store instruction was forwarded to a load.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss. Combined Unit 0 + 1.
#248,u,g,n,n,PM_LSU_SRQ_SYNC_CYC,SRQ sync duration
##830E5
Cycles that a sync instruction is active in the Store Request Queue.
#249,v,g,n,n,PM_LWSYNC_HELD,LWSYNC held at dispatch
##130E0
Cycles a LWSYNC instruction was held at dispatch. LWSYNC instructions are held at dispatch until all previous loads are done and all previous stores have issued. LWSYNC enters the Store Request Queue and is sent to the storage subsystem but does not wait for a response.
#250,v,g,n,n,PM_MEM_PWQ_DISP_Q2or3,Memory partial-write queue dispatched to Write Queue 2 or 3
##734E6
Memory partial-write queue dispatched to Write Queue 2 or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#251,v,g,n,n,PM_IC_PREF_INSTALL,Instruction prefetched installed in prefetch buffer
##210C7
A prefetch buffer entry (line) is allocated but the request is not a demand fetch.
#252,v,g,n,s,PM_MEM_HI_PRIO_WR_CMPL,High priority write completed
##726E6
A memory write,  which was upgraded to high priority, completed.  Writes can be upgraded to high priority to ensure that read traffic does not lock out writes. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#253,v,g,n,s,PM_MEM_NONSPEC_RD_CANCEL,Non speculative memory read cancelled
##711C6
A non-speculative read was cancelled because the combined response indicated it was sourced from aother L2 or L3.   This event is sent from the Memory Controller clock domain and must be scaled accordingly
#254,v,g,n,s,PM_MEM_LO_PRIO_WR_CMPL,Low priority write completed
##736E6
A memory write,  which was not upgraded to high priority, completed.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#255,v,g,n,s,PM_MEM_PWQ_DISP,Memory partial-write queue dispatched
##704C6
Number of Partial Writes dispatched.  The MC provides resources to gather partial cacheline writes (Partial line DMA writes & CI-stores) to up to four different cachelines at a time.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#256,v,g,n,n,PM_MEM_RQ_DISP_Q0to3,Memory read queue dispatched to queues 0-3
##702C6
A memory operation was dispatched to read queue 0,1,2, or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#257,v,g,n,s,PM_MEM_PW_CMPL,Memory partial-write completed
##724E6
Number of Partial Writes completed.   This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#258,v,g,n,s,PM_MEM_PW_GATH,Memory partial-write gathered
##714C6
Two or more partial-writes have been merged into a single memory write. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#259,v,g,n,n,PM_MEM_RQ_DISP_Q4to7,Memory read queue dispatched to queues 4-7
##712C6
A memory operation was dispatched to read queue 4,5,6 or 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#260,v,g,n,s,PM_MEM_RQ_DISP,Memory read queue dispatched
##701C6
A memory read was dispatched. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#261,v,g,n,n,PM_MEM_RQ_DISP_Q8to11,Memory read queue dispatched to queues 8-11
##722E6
A memory operation was dispatched to read queue 8,9,10 or 11. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#262,v,g,n,n,PM_MEM_RQ_DISP_Q12to15,Memory read queue dispatched to queues 12-15
##732E6
A memory operation was dispatched to read queue 12,13,14 or 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#263,v,g,n,s,PM_MEM_SPEC_RD_CANCEL,Speculative memory read cancelled
##721E6
Speculative memory read cancelled (i.e. cresp = sourced by L2/L3)
#264,v,g,n,n,PM_MEM_WQ_DISP_Q0to7,Memory write queue dispatched to queues 0-7
##723E6
A memory operation was dispatched to a write queue in the range between 0 and 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#265,v,g,n,n,PM_MEM_WQ_DISP_Q8to15,Memory write queue dispatched to queues 8-15
##733E6
A memory operation was dispatched to a write queue in the range between 8 and 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#266,v,g,n,s,PM_MEM_WQ_DISP_DCLAIM,Memory write queue dispatched due to dclaim/flush
##713C6
A memory dclaim or flush operation was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#267,v,g,n,s,PM_MEM_WQ_DISP_WRITE,Memory write queue dispatched due to write
##703C6
A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#268,v,g,n,n,PM_MRK_BRU_FIN,Marked instruction BRU processing finished
##00005
The branch unit finished a marked instruction. Instructions that finish may not necessary complete.
#269,v,g,n,n,PM_MRK_DATA_FROM_L25_MOD,Marked data loaded from L2.5 modified
##C7097
The processor's Data Cache was reloaded with modified (M) data from the L2 of a chip on the same module as this processor is located  due to a marked load.
#270,v,g,n,n,PM_MRK_DATA_FROM_L25_SHR_CYC,Marked load latency from L2.5 shared
##C70A2
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#271,v,g,n,n,PM_MRK_DATA_FROM_L275_SHR_CYC,Marked load latency from L2.75 shared
##C70A3
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#272,v,g,n,n,PM_MRK_DATA_FROM_L2_CYC,Marked load latency from L2
##C70A0
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#273,v,g,n,n,PM_MRK_DATA_FROM_L35_MOD,Marked data loaded from L3.5 modified
##C709E
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a marked load.
#274,v,g,n,n,PM_MRK_DATA_FROM_L35_SHR_CYC,Marked load latency from L3.5 shared
##C70A6
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#275,v,g,n,n,PM_MRK_DATA_FROM_L375_SHR_CYC,Marked load latency from L3.75 shared
##C70A7
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#276,v,g,n,n,PM_MRK_DATA_FROM_L3_CYC,Marked load latency from L3
##C70A4
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#277,v,g,n,n,PM_MRK_DATA_FROM_LMEM,Marked data loaded from local memory
##C7087
The processor's Data Cache was reloaded due to a marked load from memory attached to the same module this proccessor is located on.
#278,v,g,n,n,PM_MRK_DSLB_MISS,Marked Data SLB misses
##C50C7
A Data SLB miss was caused by a marked instruction.
#279,v,g,n,n,PM_MRK_DTLB_MISS,Marked Data TLB misses
##C50C6,C60E0
Data TLB references by a marked instruction that missed the TLB (all page sizes).
#280,v,g,n,n,PM_MRK_DTLB_MISS_64K,Marked Data TLB misses for 64K page
##C608D
Data TLB references to 64KB pages by a marked instruction that missed the TLB. Page size is determined at TLB reload time.
#281,v,g,n,n,PM_MRK_DTLB_REF,Marked Data TLB reference
##C60E4
Total number of Data TLB references by a marked instruction for all page sizes. Page size is determined at TLB reload time.
#282,v,g,n,n,PM_MRK_DTLB_REF_64K,Marked Data TLB reference for 64K page
##C6086
Data TLB references by a marked instruction for 64KB pages.
#283,v,g,n,n,PM_MRK_GRP_BR_REDIR,Group experienced marked branch redirect
##12091
A group containing a marked (sampled) instruction experienced a branch redirect.
#284,v,g,n,n,PM_MRK_IMR_RELOAD,Marked IMR reloaded
##820E2
A DL1 reload occurred due to marked load
#285,v,g,n,n,PM_MRK_L1_RELOAD_VALID,Marked L1 reload data source valid
##C70E4
The source information is valid and is for a marked load
#286,v,g,n,n,PM_MRK_LD_MISS_L1_LSU0,LSU0 marked L1 D cache load misses
##820E0
Load references that miss the Level 1 Data cache, by LSU0.
#287,v,g,n,n,PM_MRK_LD_MISS_L1_LSU1,LSU1 marked L1 D cache load misses
##820E4
Load references that miss the Level 1 Data cache, by LSU1.
#288,v,g,n,n,PM_MRK_LSU0_FLUSH_LRQ,LSU0 marked LRQ flushes
##810C2
A marked load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#289,u,g,n,n,PM_MRK_LSU0_FLUSH_SRQ,LSU0 marked SRQ lhs flushes
##810C3
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#290,v,g,n,n,PM_MRK_LSU0_FLUSH_ULD,LSU0 marked unaligned load flushes
##810C1
A marked load was flushed from unit 0 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#291,v,g,n,n,PM_MRK_LSU0_FLUSH_UST,LSU0 marked unaligned store flushes
##810C0
A marked store was flushed from unit 0 because it was unaligned
#292,v,g,n,n,PM_MRK_LSU1_FLUSH_LRQ,LSU1 marked LRQ flushes
##810C6
A marked load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#293,u,g,n,n,PM_MRK_LSU1_FLUSH_SRQ,LSU1 marked SRQ lhs flushes
##810C7
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#294,v,g,n,n,PM_MRK_LSU1_FLUSH_ULD,LSU1 marked unaligned load flushes
##810C4
A marked load was flushed from unit 1 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#295,u,g,n,n,PM_MRK_LSU1_FLUSH_UST,LSU1 marked unaligned store flushes
##810C5
A marked store was flushed from unit 1 because it was unaligned (crossed a 4k boundary)
#296,v,g,n,n,PM_MRK_LSU_FLUSH_UST,Marked unaligned store flushes
##810A8
A marked store was flushed because it was unaligned
#297,u,g,n,n,PM_MRK_LSU_SRQ_INST_VALID,Marked instruction valid in SRQ
##C70E6
This signal is asserted every cycle when a marked request is resident in the Store Request Queue
#298,v,g,n,n,PM_MRK_STCX_FAIL,Marked STCX failed
##820E6
A marked stcx (stwcx or stdcx) failed
#299,v,g,n,n,PM_MRK_ST_GPS,Marked store sent to GPS
##00003
A sampled store has been sent to the memory subsystem
#300,v,g,n,n,PM_MRK_ST_MISS_L1,Marked L1 D cache store misses
##820E3
A marked store missed the dcache
#301,v,g,n,n,PM_PMC1_OVERFLOW,PMC1 Overflow
##0000A
Overflows from PMC1 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#302,v,g,n,n,PM_INST_CMPL,Instructions completed
##00009
Number of PowerPC instructions that completed.
#303,v,g,n,n,PM_PTEG_FROM_L25_MOD,PTEG loaded from L2.5 modified
##83097
A Page Table Entry was loaded into the TLB with modified (M) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#304,v,g,n,n,PM_PTEG_FROM_L35_MOD,PTEG loaded from L3.5 modified
##8309E
A Page Table Entry was loaded into the TLB with modified (M) data from the L3 of a chip on the same module as this processor is located, due to a demand load.
#305,v,g,n,n,PM_PTEG_FROM_LMEM,PTEG loaded from local memory
##83087
A Page Table Entry was loaded into the TLB from memory attached to the same module this proccessor is located on.
#306,v,g,n,n,PM_PTEG_RELOAD_VALID,PTEG reload valid
##830E4
A Page Table Entry was loaded into the TLB.
#307,v,g,n,n,PM_SLB_MISS,SLB misses
##80088
Total of all Segment Lookaside Buffer (SLB) misses, Instructions + Data.
#308,v,g,n,s,PM_SNOOP_DCLAIM_RETRY_QFULL,Snoop dclaim/flush retry due to write/dclaim queues full
##720E6
The memory controller A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#309,v,g,n,s,PM_SNOOP_PARTIAL_RTRY_QFULL,Snoop partial write retry due to partial-write queues full
##730E6
A snoop request for a partial write to memory was retried because the write queues that handle partial writes were full. When this happens the active writes are changed to high priority. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#310,v,g,n,s,PM_SNOOP_PW_RETRY_RQ,Snoop partial-write retry due to collision with active read queue
##707C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#311,v,g,n,s,PM_SNOOP_PW_RETRY_WQ_PWQ,Snoop partial-write retry due to collision with active write or partial-write queue
##717C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active write or partial write.  When this happens the snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#312,v,g,n,s,PM_SNOOP_RD_RETRY_QFULL,Snoop read retry due to read queue full
##700C6
A snoop request for a read from memory was retried because the read queues were full.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#313,v,g,n,s,PM_SNOOP_RD_RETRY_RQ,Snoop read retry due to collision with active read queue
##705C6
A snoop request for a read from memory was retried because it matched the cache line of an active read.  The snoop request is retried because the L2 may be able to source data via intervention for the 2nd read faster than the MC.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#314,v,g,n,s,PM_SNOOP_RD_RETRY_WQ,Snoop read retry due to collision with active write queue
##715C6
A snoop request for a read from memory was retried because it matched the cache line of an active write. The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#315,v,g,n,s,PM_SNOOP_RETRY_1AHEAD,Snoop retry due to one ahead collision
##725E6
Snoop retry due to one ahead collision
#316,u,g,n,s,PM_SNOOP_TLBIE,Snoop TLBIE
##800C3
A tlbie was snooped from another processor.
#317,v,g,n,s,PM_SNOOP_WR_RETRY_QFULL,Snoop read retry due to read queue full
##710C6
A snoop request for a write to memory was retried because the write queues were full.  When this happens the snoop request is retried and the writes in the write reorder queue are changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#318,v,g,n,s,PM_SNOOP_WR_RETRY_RQ,Snoop write/dclaim retry due to collision with active read queue
##706C6
A snoop request for a write or dclaim to memory was retried because it matched the cacheline of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#319,v,g,n,s,PM_SNOOP_WR_RETRY_WQ,Snoop write/dclaim retry due to collision with active write queue
##716C6
A snoop request for a write or dclaim to memory was retried because it matched the cache line of an active write.  The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#320,v,g,n,n,PM_STCX_FAIL,STCX failed
##820E1
A stcx (stwcx or stdcx) failed
#321,v,g,n,n,PM_STCX_PASS,Stcx passes
##820E5
A stcx (stwcx or stdcx) instruction was successful
#322,v,g,n,n,PM_ST_MISS_L1,L1 D cache store misses
##C10C3
A store missed the dcache.  Combined Unit 0 + 1.
#323,v,g,n,n,PM_ST_REF_L1,L1 D cache store references
##C10A8
Store references to the Data Cache. Combined Unit 0 + 1.
#324,v,g,n,n,PM_ST_REF_L1_LSU0,LSU0 L1 D cache store references
##C10C1
Store references to the Data Cache by LSU0.
#325,v,g,n,n,PM_ST_REF_L1_LSU1,LSU1 L1 D cache store references
##C10C4
Store references to the Data Cache by LSU1.
#326,v,g,n,n,PM_SUSPENDED,Suspended
##00000
The counter is suspended (does not count).
#327,v,g,n,n,PM_THRD_GRP_CMPL_BOTH_CYC,Cycles group completed by both threads
##00013
Cycles that both threads completed.
#328,v,g,n,s,PM_THRD_L2MISS_BOTH_CYC,Cycles both threads in L2 misses
##410C7
Cycles that both threads have L2 miss pending.  If only one thread has a L2 miss pending the other thread is given priority at decode.  If both threads have L2 miss pending decode priority is determined by the number of GCT entries used.
#329,v,g,n,n,PM_THRD_PRIO_1_CYC,Cycles thread running at priority level 1
##420E0
Cycles this thread was running at priority level 1. Priority level 1 is the lowest and indicates the thread is sleeping.
#330,v,g,n,n,PM_THRD_PRIO_2_CYC,Cycles thread running at priority level 2
##420E1
Cycles this thread was running at priority level 2.
#331,v,g,n,n,PM_THRD_PRIO_3_CYC,Cycles thread running at priority level 3
##420E2
Cycles this thread was running at priority level 3.
#332,v,g,n,n,PM_THRD_PRIO_4_CYC,Cycles thread running at priority level 4
##420E3
Cycles this thread was running at priority level 4.
#333,v,g,n,n,PM_THRD_PRIO_5_CYC,Cycles thread running at priority level 5
##420E4
Cycles this thread was running at priority level 5.
#334,v,g,n,n,PM_THRD_PRIO_6_CYC,Cycles thread running at priority level 6
##420E5
Cycles this thread was running at priority level 6.
#335,v,g,n,n,PM_THRD_PRIO_7_CYC,Cycles thread running at priority level 7
##420E6
Cycles this thread was running at priority level 7.
#336,v,g,n,n,PM_THRD_PRIO_DIFF_0_CYC,Cycles no thread priority difference
##430E3
Cycles when this thread's priority is equal to the other thread's priority.
#337,v,g,n,n,PM_THRD_PRIO_DIFF_1or2_CYC,Cycles thread priority difference is 1 or 2
##430E4
Cycles when this thread's priority is higher than the other thread's priority by 1 or 2.
#338,v,g,n,n,PM_THRD_PRIO_DIFF_3or4_CYC,Cycles thread priority difference is 3 or 4
##430E5
Cycles when this thread's priority is higher than the other thread's priority by 3 or 4.
#339,v,g,n,n,PM_THRD_PRIO_DIFF_5or6_CYC,Cycles thread priority difference is 5 or 6
##430E6
Cycles when this thread's priority is higher than the other thread's priority by 5 or 6.
#340,v,g,n,n,PM_THRD_PRIO_DIFF_minus1or2_CYC,Cycles thread priority difference is -1 or -2
##430E2
Cycles when this thread's priority is lower than the other thread's priority by 1 or 2.
#341,v,g,n,n,PM_THRD_PRIO_DIFF_minus3or4_CYC,Cycles thread priority difference is -3 or -4
##430E1
Cycles when this thread's priority is lower than the other thread's priority by 3 or 4.
#342,v,g,n,n,PM_THRD_PRIO_DIFF_minus5or6_CYC,Cycles thread priority difference is -5 or -6
##430E0
Cycles when this thread's priority is lower than the other thread's priority by 5 or 6.
#343,v,g,n,s,PM_THRD_SEL_OVER_CLB_EMPTY,Thread selection overrides caused by CLB empty
##410C2
Thread selection was overridden because one thread's CLB was empty.
#344,v,g,n,s,PM_THRD_SEL_OVER_GCT_IMBAL,Thread selection overrides caused by GCT imbalance
##410C4
Thread selection was overridden because of a GCT imbalance.
#345,v,g,n,s,PM_THRD_SEL_OVER_ISU_HOLD,Thread selection overrides caused by ISU holds
##410C5
Thread selection was overridden because of an ISU hold.
#346,v,g,n,s,PM_THRD_SEL_OVER_L2MISS,Thread selection overrides caused by L2 misses
##410C3
Thread selection was overridden because one thread was had a L2 miss pending.
#347,v,g,n,s,PM_THRD_SEL_T0,Decode selected thread 0
##410C0
Thread selection picked thread 0 for decode.
#348,v,g,n,s,PM_THRD_SEL_T1,Decode selected thread 1
##410C1
Thread selection picked thread 1 for decode.
#349,v,g,n,s,PM_THRD_SMT_HANG,SMT hang detected
##330E7
A hung thread was detected
#350,v,g,n,n,PM_TLBIE_HELD,TLBIE held at dispatch
##130E4
Cycles a TLBIE instruction was held at dispatch.
#351,v,g,n,s,PM_XER_MAP_FULL_CYC,Cycles XER mapper full
##100C2
The XER mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#352,v,g,n,n,PM_BR_PRED_CR,A conditional branch was predicted, CR prediction
##230E2
A conditional branch instruction was predicted as taken or not taken.
#353,v,g,n,n,PM_MEM_RQ_DISP_Q16to19,Memory read queue dispatched to queues 16-19
##727E6
A memory operation was dispatched to read queue 16,17,18 or 19. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#354,c,g,n,n,PM_MEM_FAST_PATH_RD_DISP,Fast path memory read dispatched
##731E6
Fast path memory read dispatched
#355,v,g,n,n,PM_SNOOP_RETRY_AB_COLLISION,Snoop retry due to a b collision
##735E6
Snoop retry due to a b collision

$$$$$$$$

{ counter 3 }
#0,v,g,n,n,PM_0INST_CLB_CYC,Cycles no instructions in CLB
##400C0
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#1,v,g,n,n,PM_1INST_CLB_CYC,Cycles 1 instruction in CLB
##400C1
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#2,v,g,n,n,PM_2INST_CLB_CYC,Cycles 2 instructions in CLB
##400C2
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#3,v,g,n,n,PM_3INST_CLB_CYC,Cycles 3 instructions in CLB
##400C3
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#4,v,g,n,n,PM_4INST_CLB_CYC,Cycles 4 instructions in CLB
##400C4
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#5,v,g,n,n,PM_5INST_CLB_CYC,Cycles 5 instructions in CLB
##400C5
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#6,v,g,n,n,PM_6INST_CLB_CYC,Cycles 6 instructions in CLB
##400C6
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#7,u,g,n,s,PM_BRQ_FULL_CYC,Cycles branch queue full
##100C5
Cycles when the issue queue that feeds the branch unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#8,v,g,n,n,PM_BR_ISSUED,Branches issued
##230E4
A branch instruction was issued to the branch unit.  A branch that was incorrectly predicted may issue and execute multiple times.
#9,v,g,n,n,PM_BR_MPRED_CR,Branch mispredictions due to CR bit setting
##230E5
A conditional branch instruction was incorrectly predicted as taken or not taken.  The branch execution unit detects a branch mispredict because the CR value is opposite of the predicted value. This will result in a branch redirect flush if not overfidden by a flush of an older instruction.
#10,v,g,n,n,PM_BR_MPRED_TA,Branch mispredictions due to target address
##230E6
A branch instruction target was incorrectly predicted. This will result in a branch mispredict flush unless a flush is detected from an older instruction.
#11,v,g,n,n,PM_BR_PRED_CR,A conditional branch was predicted, CR prediction
##23087,230E2
A conditional branch instruction was predicted as taken or not taken.
#12,v,g,n,s,PM_CLB_EMPTY_CYC,Cycles CLB empty
##410C6
Cycles when both thread's CLB is completely empty.
#13,v,g,n,n,PM_CLB_FULL_CYC,Cycles CLB full
##220E5
Cycles when both thread's CLB is full.
#14,u,g,n,s,PM_CRQ_FULL_CYC,Cycles CR issue queue full
##110C1
The issue queue that feeds the Conditional Register unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#15,v,g,n,s,PM_CR_MAP_FULL_CYC,Cycles CR logical operation mapper full
##100C4
The Conditional Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#16,v,g,n,s,PM_CYC,Processor cycles
##0000F
Processor cycles
#17,v,g,n,n,PM_DATA_FROM_L25_MOD,Data loaded from L2.5 modified
##C30A2
The processor's Data Cache was reloaded with modified (M) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#18,v,g,n,n,PM_DATA_FROM_L275_SHR,Data loaded from L2.75 shared
##C3097
The processor's Data Cache was reloaded with shared (T) data from the L2 on a different module than this processor is located due to a demand load.
#19,v,g,n,n,PM_DATA_FROM_L2MISS,Data loaded missed L2
##C309B
The processor's Data Cache was reloaded but not from the local L2.
#20,v,g,n,n,PM_DATA_FROM_L3,Data loaded from L3
##C30AF
The processor's Data Cache was reloaded from the local L3 due to a demand load.
#21,v,g,n,n,PM_DATA_FROM_L35_MOD,Data loaded from L3.5 modified
##C30A6
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a demand load.
#22,v,g,n,n,PM_DATA_FROM_L375_SHR,Data loaded from L3.75 shared
##C309E
The processor's Data Cache was reloaded with shared (S) data from the L3 of a chip on a different module than this processor is located due to a demand load.
#23,v,g,n,n,PM_DATA_FROM_LMEM,Data loaded from local memory
##C30A0
The processor's Data Cache was reloaded from memory attached to the same module this proccessor is located on.
#24,v,g,n,n,PM_DATA_TABLEWALK_CYC,Cycles doing data tablewalks
##800C7
Cycles a translation tablewalk is active.  While a tablewalk is active any request attempting to access the TLB will be rejected and retried.
#25,u,g,n,s,PM_DC_INV_L2,L1 D cache entries invalidated from L2
##C10C7
A dcache invalidated was received from the L2 because a line in L2 was castout.
#26,v,g,n,n,PM_DC_PREF_OUT_OF_STREAMS,D cache out of prefetch streams
##C50C2
A new prefetch stream was detected but no more stream entries were available.
#27,v,g,n,n,PM_DC_PREF_DST,DST (Data Stream Touch) stream start
##830E6
A prefetch stream was started using the DST instruction.
#28,v,g,n,n,PM_DC_PREF_STREAM_ALLOC,D cache new prefetch stream allocated
##830E7
A new Prefetch Stream was allocated.
#29,v,g,n,n,PM_DSLB_MISS,Data SLB misses
##800C5
A SLB miss for a data request occurred. SLB misses trap to the operating system to resolve.
#30,v,g,n,n,PM_DTLB_MISS,Data TLB misses
##800C4,C20E0
Data TLB misses, all page sizes.
#31,v,g,n,n,PM_DTLB_MISS_16M,Data TLB miss for 16M page
##C208D
Data TLB references to 16MB pages that missed the TLB. Page size is determined at TLB reload time.
#32,v,g,n,n,PM_DTLB_REF,Data TLB references
##C20E4
Total number of Data TLB references for all page sizes. Page size is determined at TLB reload time.
#33,v,g,n,n,PM_DTLB_REF_16M,Data TLB reference for 16M page
##C2086
Data TLB references for 16MB pages. Includes hits + misses.
#34,v,g,n,n,PM_EE_OFF,Cycles MSR(EE) bit off
##130E3
Cycles MSR(EE) bit was off indicating that interrupts due to external exceptions were masked.
#35,u,g,n,n,PM_EE_OFF_EXT_INT,Cycles MSR(EE) bit off and external interrupt pending
##130E7
Cycles when an interrupt due to an external exception is pending but external exceptions were masked.
#36,v,g,n,s,PM_FAB_CMD_ISSUED,Fabric command issued
##700C7
Incremented when a chip issues a command on its SnoopA address bus. Each of the two address busses (SnoopA and SnoopB) is capable of one transaction per fabric cycle (one fabric cycle = 2 cpu cycles in normal 2:1 mode), but each chip can only drive the SnoopA bus, and can only drive one transaction every two fabric cycles (i.e., every four cpu cycles). In MCM-based systems, two chips interleave their accesses to each of the two fabric busses (SnoopA, SnoopB) to reach a peak capability of one transaction per cpu clock cycle. The two chips that drive SnoopB are wired so that the chips refer to the bus as SnoopA but it is connected to the other two chips as SnoopB.  Note that this event will only be recorded by the FBC on the chip that sourced the operation. The signal is delivered at FBC speed and the count must be scaled.
#37,v,g,n,n,PM_FAB_CMD_RETRIED,Fabric command retried
##710C7
Incremented when a command issued by a chip on its SnoopA address bus is retried for any reason. The overwhelming majority of retries are due to running out of memory controller queues but retries can also be caused by trying to reference addresses that are in a transient cache state -- e.g. a line is transient after issuing a DCLAIM instruction to a shared line but before the associated store completes.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#38,v,g,n,s,PM_FAB_DCLAIM_ISSUED,dclaim issued
##720E7
A DCLAIM command was issued. Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#39,v,g,n,s,PM_FAB_DCLAIM_RETRIED,dclaim retried
##730E7
A DCLAIM command was retried.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#40,v,g,n,s,PM_FAB_HOLDtoNN_EMPTY,Hold buffer to NN empty
##722E7
Fabric cyles when the Next Node out hold-buffers are emtpy.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#41,v,g,n,s,PM_FAB_HOLDtoVN_EMPTY,Hold buffer to VN empty
##721E7
Fabric cycles when the Vertical Node out hold-buffers are emtpy. The signal is delivered at FBC speed and the count must be scaled accordingly.
#42,v,g,n,s,PM_FAB_M1toP1_SIDECAR_EMPTY,M1 to P1 sidecar empty
##702C7
Fabric cycles when the Minus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#43,v,g,n,s,PM_FAB_M1toVNorNN_SIDECAR_EMPTY,M1 to VN/NN sidecar empty
##712C7
Fabric cycles when the Minus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#44,v,g,n,s,PM_FAB_P1toM1_SIDECAR_EMPTY,P1 to M1 sidecar empty
##701C7
Fabric cycles when the Plus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#45,v,g,n,s,PM_FAB_P1toVNorNN_SIDECAR_EMPTY,P1 to VN/NN sidecar empty
##711C7
Fabric cycles when the Plus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#46,v,g,n,s,PM_FAB_PNtoNN_DIRECT,PN to NN beat went straight to its destination
##703C7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound NN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled.
#47,v,g,n,s,PM_FAB_PNtoNN_SIDECAR,PN to NN beat went to sidecar first
##713C7
Fabric Data beats that the base chip takes the inbound PN data and forwards it on to the outbound NN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled.
#48,v,g,n,s,PM_FAB_PNtoVN_DIRECT,PN to VN beat went straight to its destination
##723E7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound VN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled accordingly.
#49,v,g,n,s,PM_FAB_PNtoVN_SIDECAR,PN to VN beat went to sidecar first
##733E7
Fabric data beats that the base chip takes the inbound PN data and forwards it on to the outbound VN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled accordingly.
#50,v,g,n,s,PM_FAB_VBYPASS_EMPTY,Vertical bypass buffer empty
##731E7
Fabric cycles when the Middle Bypass sidecar is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#51,v,g,n,n,PM_FLUSH,Flushes
##110C7
Flushes occurred including LSU and Branch flushes.
#52,v,g,n,n,PM_FLUSH_BR_MPRED,Flush caused by branch mispredict
##110C6
A flush was caused by a branch mispredict.
#53,v,g,n,s,PM_FLUSH_IMBAL,Flush caused by thread GCT imbalance
##330E3
This thread has been flushed at dispatch because it is stalled and a GCT imbalance exists.  GCT thresholds are set in the TSCR register. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#54,v,g,n,s,PM_FLUSH_SB,Flush caused by scoreboard operation
##330E2
This thread has been flushed at dispatch because its scoreboard bit is set indicating that a non-renamed resource is being updated. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#55,v,g,n,s,PM_FLUSH_SYNC,Flush caused by sync
##330E1
This thread has been flushed at dispatch due to a sync, lwsync, ptesync, or tlbsync instruction.  This allows the other thread to have more machine resources for it to make progress until the sync finishes.
#56,v,g,n,s,PM_FPR_MAP_FULL_CYC,Cycles FPR mapper full
##100C1
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#57,v,g,n,n,PM_FPU0_1FLOP,FPU0 executed add, mult, sub, cmp or sel instruction
##000C3
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#58,v,g,n,n,PM_FPU0_DENORM,FPU0 received denormalized data
##020E0
FPU0 has encountered a denormalized operand.
#59,v,g,n,n,PM_FPU0_FDIV,FPU0 executed FDIV instruction
##000C0
FPU0 has executed a divide instruction. This could be fdiv, fdivs, fdiv. fdivs.
#60,v,g,n,n,PM_FPU0_FEST,FPU0 executed FEST instruction
##010C2
FPU0 has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#61,v,g,n,n,PM_FPU0_FIN,FPU0 produced a result
##010C3
FPU0 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads.
#62,v,g,n,n,PM_FPU0_FMA,FPU0 executed multiply-add instruction
##000C1
The floating point unit has executed a multiply-add kind of instruction.  This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#63,v,g,n,n,PM_FPU0_FMOV_FEST,FPU0 executed FMOV or FEST instructions
##010C0
FPU0 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#64,v,g,n,n,PM_FPU0_FPSCR,FPU0 executed FPSCR instruction
##030E0
FPU0 has executed FPSCR move related instruction. This could be mtfsfi*, mtfsb0*, mtfsb1*, mffs*, mtfsf*, mcrsf* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#65,v,g,n,n,PM_FPU0_FRSP_FCONV,FPU0 executed FRSP or FCONV instructions
##010C1
FPU0 has executed a frsp or convert kind of instruction. This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#66,v,g,n,n,PM_FPU0_FSQRT,FPU0 executed FSQRT instruction
##000C2
FPU0 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#67,v,g,n,s,PM_FPU0_FULL_CYC,Cycles FPU0 issue queue full
##100C3
The issue queue for FPU0 cannot accept any more instruction. Dispatch to this issue queue is stopped.
#68,v,g,n,n,PM_FPU0_SINGLE,FPU0 executed single precision instruction
##020E3
FPU0 has executed a single precision instruction.
#69,v,g,n,n,PM_FPU0_STALL3,FPU0 stalled in pipe3
##020E1
FPU0 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#70,v,g,n,n,PM_FPU0_STF,FPU0 executed store instruction
##020E2
FPU0 has executed a Floating Point Store instruction.
#71,v,g,n,n,PM_FPU1_1FLOP,FPU1 executed add, mult, sub, cmp or sel instruction
##000C7
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#72,v,g,n,n,PM_FPU1_DENORM,FPU1 received denormalized data
##020E4
FPU1 has encountered a denormalized operand.
#73,v,g,n,n,PM_FPU1_FDIV,FPU1 executed FDIV instruction
##000C4
FPU1 has executed a divide instruction.  This could be fdiv, fdivs, fdiv. fdivs.
#74,v,g,n,n,PM_FPU1_FEST,FPU1 executed FEST instruction
##010C6
FPU1 has executed an estimate instructions.  This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#75,v,g,n,n,PM_FPU1_FIN,FPU1 produced a result
##010C7
FPU1 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads., ,
#76,v,g,n,n,PM_FPU1_FMA,FPU1 executed multiply-add instruction
##000C5
The floating point unit has executed a multiply-add kind of instruction. This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#77,v,g,n,n,PM_FPU1_FMOV_FEST,FPU1 executed FMOV or FEST instructions
##010C4
FPU1 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#78,v,g,n,n,PM_FPU1_FRSP_FCONV,FPU1 executed FRSP or FCONV instructions
##010C5
FPU1 has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#79,v,g,n,n,PM_FPU1_FSQRT,FPU1 executed FSQRT instruction
##000C6
FPU1 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#80,v,g,n,s,PM_FPU1_FULL_CYC,Cycles FPU1 issue queue full
##100C7
The issue queue for FPU1 cannot accept any more instructions. Dispatch to this issue queue is stopped
#81,v,g,n,n,PM_FPU1_SINGLE,FPU1 executed single precision instruction
##020E7
FPU1 has executed a single precision instruction.
#82,v,g,n,n,PM_FPU1_STALL3,FPU1 stalled in pipe3
##020E5
FPU1 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#83,v,g,n,n,PM_FPU1_STF,FPU1 executed store instruction
##020E6
FPU1 has executed a Floating Point Store instruction.
#84,v,g,n,n,PM_FPU_FMOV_FEST,FPU executed FMOV or FEST instructions
##01088
The floating point unit has executed a move kind of instruction or one of the estimate instructions. This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.. Combined Unit 0 + Unit 1.
#85,v,g,n,n,PM_FPU_FRSP_FCONV,FPU executed FRSP or FCONV instructions
##01090
The floating point unit has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs. Combined Unit 0 + Unit 1.
#86,v,g,n,n,PM_FPU_FSQRT,FPU executed FSQRT instruction
##000A8
The floating point unit has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs. Combined Unit 0 + Unit 1.
#87,v,g,n,n,PM_FPU_STF,FPU executed store instruction
##020A8
FPU has executed a store instruction. Combined Unit 0 + Unit 1.
#88,v,g,n,s,PM_FXLS0_FULL_CYC,Cycles FXU0/LS0 queue full
##110C0
The issue queue that feeds the Fixed Point unit 0 / Load Store Unit 0 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#89,v,g,n,s,PM_FXLS1_FULL_CYC,Cycles FXU1/LS1 queue full
##110C4
The issue queue that feeds the Fixed Point unit 1 / Load Store Unit 1 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#90,u,g,n,n,PM_FXU0_BUSY_FXU1_IDLE,FXU0 busy FXU1 idle
##00012
FXU0 is busy while FXU1 was idle
#91,v,g,n,n,PM_FXU0_FIN,FXU0 produced a result
##130E2
The Fixed Point unit 0 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#92,v,g,n,n,PM_FXU1_FIN,FXU1 produced a result
##130E6
The Fixed Point unit 1 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#93,v,g,n,n,PM_FXU_FIN,FXU produced a result
##13088
The fixed point unit (Unit 0 + Unit 1) finished an instruction. Instructions that finish may not necessary complete.
#94,v,g,n,n,PM_GCT_FULL_CYC,Cycles GCT full
##100C0
The Global Completion Table is completely full.
#95,v,g,n,n,PM_GCT_NOSLOT_SRQ_FULL,No slot in GCT caused by SRQ full
##10084
Cycles when the Global Completion Table has no slots from this thread because the Store Request Queue (SRQ)  is full.  This happens when the storage subsystem can not process the stores in the SRQ.  Groups can not be dispatched until a SRQ entry is available.
#96,v,g,n,s,PM_GCT_USAGE_80to99_CYC,Cycles GCT 80-99% full
##0001F
Cycles when the Global Completion Table has between 80% and 99% of its slots used.  The GCT has 20 entries shared between threads
#97,v,g,n,s,PM_GPR_MAP_FULL_CYC,Cycles GPR mapper full
##130E5
The General Purpose Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#98,v,g,n,n,PM_GRP_BR_REDIR,Group experienced branch redirect
##120E6
Number of groups, counted at dispatch, that have encountered a branch redirect.  Every group constructed from a fetch group that has been redirected will count.
#99,c,g,n,n,PM_GRP_IC_MISS_BR_REDIR_NONSPEC,Group experienced non-speculative I cache miss or branch redirect
##120E5
Group experienced non-speculative I cache miss or branch redirect
#100,v,g,n,n,PM_GRP_CMPL,Group completed
##00013
A group completed. Microcoded instructions that span multiple groups will generate this event once per group.
#101,v,g,n,n,PM_GRP_DISP_BLK_SB_CYC,Cycles group dispatch blocked by scoreboard
##130E1
A scoreboard operation on a non-renamed resource has blocked dispatch.
#102,v,g,n,n,PM_GRP_DISP_REJECT,Group dispatch rejected
##120E4
A group that previously attempted dispatch was rejected.
#103,v,g,n,n,PM_GRP_DISP_SUCCESS,Group dispatch success
##00002
Number of groups sucessfully dispatched (not rejected)
#104,v,g,n,n,PM_GRP_DISP_VALID,Group dispatch valid
##120E3
A group is available for dispatch.  This does not mean it was successfully dispatched.
#105,v,g,n,n,PM_GRP_IC_MISS,Group experienced I cache miss
##120E7
Number of groups, counted at dispatch, that have encountered an icache miss redirect.  Every group constructed from a fetch group that missed the instruction cache will count.
#106,v,g,n,n,PM_IC_DEMAND_L2_BHT_REDIRECT,L2 I cache demand request due to BHT redirect
##230E0
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (CR mispredict).
#107,v,g,n,n,PM_IC_DEMAND_L2_BR_REDIRECT,L2 I cache demand request due to branch redirect
##230E1
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (either ALL mispredicted or Target).
#108,v,g,n,n,PM_IC_PREF_INSTALL,Instruction prefetched installed in prefetch buffer
##210C7
A prefetch buffer entry (line) is allocated but the request is not a demand fetch.
#109,v,g,n,n,PM_IC_PREF_REQ,Instruction prefetch requests
##220E6
An instruction prefetch request has been made.
#110,v,g,n,n,PM_IERAT_XLATE_WR,Translation written to ierat
##220E7
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#111,v,g,n,n,PM_IERAT_XLATE_WR_LP,Large page translation written to ierat
##210C6
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#112,v,g,n,n,PM_IOPS_CMPL,Internal operations completed
##00001
Number of internal operations that completed.
#113,v,g,n,n,PM_INST_DISP,Instructions dispatched
##00009
Number of PowerPC instructions successfully dispatched.
#114,v,g,n,n,PM_INST_FETCH_CYC,Cycles at least 1 instruction fetched
##220E4
Cycles when at least one instruction was sent from the fetch unit to the decode unit.
#115,v,g,n,n,PM_INST_FROM_L275_SHR,Instruction fetched from L2.75 shared
##22096
An instruction fetch group was fetched with shared (T) data from the L2 on a different module than this processor is located. Fetch groups can contain up to 8 instructions
#116,v,g,n,n,PM_INST_FROM_L3,Instruction fetched from L3
##220AE
An instruction fetch group was fetched from the local L3. Fetch groups can contain up to 8 instructions
#117,v,g,n,n,PM_INST_FROM_L375_SHR,Instruction fetched from L3.75 shared
##2209D
An instruction fetch group was fetched with shared  (S) data from the L3 of a chip on a different module than this processor is located.  Fetch groups can contain up to 8 instructions
#118,v,g,n,n,PM_INST_FROM_PREF,Instruction fetched from prefetch
##2208D
An instruction fetch group was fetched from the prefetch buffer. Fetch groups can contain up to 8 instructions
#119,u,g,n,n,PM_ISLB_MISS,Instruction SLB misses
##800C1
A SLB miss for an instruction fetch as occurred
#120,v,g,n,n,PM_ITLB_MISS,Instruction TLB misses
##800C0
A TLB miss for an Instruction Fetch has occurred
#121,v,g,n,n,PM_L1_DCACHE_RELOAD_VALID,L1 reload data source valid
##C30E4
The data source information is valid,the data cache has been reloaded.  Prior to POWER5+ this included data cache reloads due to prefetch activity.  With POWER5+ this now only includes reloads due to demand loads.
#122,v,g,n,n,PM_L1_PREF,L1 cache data prefetches
##C70E7
A request to prefetch data into the L1 was made
#123,v,g,n,n,PM_L1_WRITE_CYC,Cycles writing to instruction L1
##230E7
Cycles that a cache line was written to the instruction cache.
#124,v,g,n,s,PM_L2SA_MOD_INV,L2 slice A transition from modified to invalid
##730E0
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#125,v,g,n,s,PM_L2SA_MOD_TAG,L2 slice A transition from modified to tagged
##720E0
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#126,v,g,n,s,PM_L2SA_RCLD_DISP,L2 slice A RC load dispatch attempt
##701C0
A Read/Claim dispatch for a Load was attempted
#127,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_ADDR,L2 slice A RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C0
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#128,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_OTHER,L2 slice A RC load dispatch attempt failed due to other reasons
##731E0
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#129,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_RC_FULL,L2 slice A RC load dispatch attempt failed due to all RC full
##721E0
A Read/Claim dispatch for a load failed because all RC machines are busy.
#130,v,g,n,s,PM_L2SA_RCST_DISP,L2 slice A RC store dispatch attempt
##702C0
A Read/Claim dispatch for a Store was attempted.
#131,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_ADDR,L2 slice A RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C0
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#132,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_OTHER,L2 slice A RC store dispatch attempt failed due to other reasons
##732E0
A Read/Claim dispatch for a store failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#133,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_RC_FULL,L2 slice A RC store dispatch attempt failed due to all RC full
##722E0
A Read/Claim dispatch for a store failed because all RC machines are busy.
#134,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY,L2 slice A RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C0
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#135,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice A RC dispatch attempt failed due to all CO busy
##713C0
A Read/Claim dispatch was rejected because all Castout machines were busy.
#136,v,g,n,s,PM_L2SA_SHR_INV,L2 slice A transition from shared to invalid
##710C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#137,v,g,n,s,PM_L2SA_SHR_MOD,L2 slice A transition from shared to modified
##700C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#138,v,g,n,n,PM_L2SA_ST_HIT,L2 slice A store hits
##733E0
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B, and C.
#139,v,g,n,n,PM_L2SA_ST_REQ,L2 slice A store requests
##723E0
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#140,v,g,n,s,PM_L2SB_MOD_INV,L2 slice B transition from modified to invalid
##730E1
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#141,v,g,n,s,PM_L2SB_MOD_TAG,L2 slice B transition from modified to tagged
##720E1
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#142,v,g,n,s,PM_L2SB_RCLD_DISP,L2 slice B RC load dispatch attempt
##701C1
A Read/Claim dispatch for a Load was attempted
#143,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_ADDR,L2 slice B RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C1
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#144,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_OTHER,L2 slice B RC load dispatch attempt failed due to other reasons
##731E1
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#145,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_RC_FULL,L2 slice B RC load dispatch attempt failed due to all RC full
##721E1
A Read/Claim dispatch for a load failed because all RC machines are busy.
#146,v,g,n,s,PM_L2SB_RCST_DISP,L2 slice B RC store dispatch attempt
##702C1
A Read/Claim dispatch for a Store was attempted.
#147,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_ADDR,L2 slice B RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C1
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#148,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_OTHER,L2 slice B RC store dispatch attempt failed due to other reasons
##732E1
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#149,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_RC_FULL,L2 slice B RC store dispatch attempt failed due to all RC full
##722E2
A Read/Claim dispatch for a store failed because all RC machines are busy.
#150,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY,L2 slice B RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C1
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#151,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice B RC dispatch attempt failed due to all CO busy
##713C1
A Read/Claim dispatch was rejected because all Castout machines were busy.
#152,v,g,n,s,PM_L2SB_SHR_INV,L2 slice B transition from shared to invalid
##710C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#153,v,g,n,s,PM_L2SB_SHR_MOD,L2 slice B transition from shared to modified
##700C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#154,v,g,n,n,PM_L2SB_ST_HIT,L2 slice B store hits
##733E1
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B and C.
#155,v,g,n,n,PM_L2SB_ST_REQ,L2 slice B store requests
##723E1
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#156,v,g,n,s,PM_L2SC_MOD_INV,L2 slice C transition from modified to invalid
##730E2
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#157,v,g,n,s,PM_L2SC_MOD_TAG,L2 slice C transition from modified to tagged
##720E2
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#158,v,g,n,s,PM_L2SC_RCLD_DISP,L2 slice C RC load dispatch attempt
##701C2
A Read/Claim dispatch for a Load was attempted
#159,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_ADDR,L2 slice C RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C2
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#160,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_OTHER,L2 slice C RC load dispatch attempt failed due to other reasons
##731E2
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#161,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_RC_FULL,L2 slice C RC load dispatch attempt failed due to all RC full
##721E2
A Read/Claim dispatch for a load failed because all RC machines are busy.
#162,v,g,n,s,PM_L2SC_RCST_DISP,L2 slice C RC store dispatch attempt
##702C2
A Read/Claim dispatch for a Store was attempted.
#163,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_ADDR,L2 slice C RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C2
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#164,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_OTHER,L2 slice C RC store dispatch attempt failed due to other reasons
##732E2
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#165,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_RC_FULL,L2 slice C RC store dispatch attempt failed due to all RC full
##722E1
A Read/Claim dispatch for a store failed because all RC machines are busy.
#166,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY,L2 slice C RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C2
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#167,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice C RC dispatch attempt failed due to all CO busy
##713C2
A Read/Claim dispatch was rejected because all Castout machines were busy.
#168,v,g,n,s,PM_L2SC_SHR_INV,L2 slice C transition from shared to invalid
##710C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#169,v,g,n,s,PM_L2SC_SHR_MOD,L2 slice C transition from shared to modified
##700C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#170,v,g,n,n,PM_L2SC_ST_HIT,L2 slice C store hits
##733E2
A store request made from the core hit in the L2 directory.  The event is provided on each of the  three slices A, B, and C.
#171,v,g,n,n,PM_L2SC_ST_REQ,L2 slice C store requests
##723E2
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#172,v,g,n,n,PM_L2_PREF,L2 cache prefetches
##C50C3
A request to prefetch data into L2 was made
#173,v,g,n,s,PM_L3SA_ALL_BUSY,L3 slice A active for every cycle all CI/CO machines busy
##721E3
Cycles All Castin/Castout machines are busy.
#174,v,g,n,s,PM_L3SA_HIT,L3 slice A hits
##711C3
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#175,v,g,n,s,PM_L3SA_MOD_INV,L3 slice A transition from modified to invalid
##730E3
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#176,v,g,n,s,PM_L3SA_MOD_TAG,L3 slice A transition from modified to TAG
##720E3
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case) Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#177,v,g,n,s,PM_L3SA_REF,L3 slice A references
##701C3
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#178,v,g,n,s,PM_L3SA_SHR_INV,L3 slice A transition from shared to invalid
##710C3
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#179,v,g,n,s,PM_L3SA_SNOOP_RETRY,L3 slice A snoop retries
##731E3
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#180,v,g,n,s,PM_L3SB_ALL_BUSY,L3 slice B active for every cycle all CI/CO machines busy
##721E4
Cycles All Castin/Castout machines are busy.
#181,v,g,n,s,PM_L3SB_HIT,L3 slice B hits
##711C4
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#182,v,g,n,s,PM_L3SB_MOD_INV,L3 slice B transition from modified to invalid
##730E4
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I).  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#183,v,g,n,s,PM_L3SB_MOD_TAG,L3 slice B transition from modified to TAG
##720E4
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#184,v,g,n,s,PM_L3SB_REF,L3 slice B references
##701C4
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#185,v,g,n,s,PM_L3SB_SHR_INV,L3 slice B transition from shared to invalid
##710C4
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#186,v,g,n,s,PM_L3SB_SNOOP_RETRY,L3 slice B snoop retries
##731E4
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#187,v,g,n,s,PM_L3SC_ALL_BUSY,L3 slice C active for every cycle all CI/CO machines busy
##721E5
Cycles All Castin/Castout machines are busy.
#188,v,g,n,s,PM_L3SC_HIT,L3 slice C hits
##711C5
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 Slice
#189,v,g,n,s,PM_L3SC_MOD_INV,L3 slice C transition from modified to invalid
##730E5
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a previous read op Tx is not included since it is considered shared at this point.
#190,v,g,n,s,PM_L3SC_MOD_TAG,L3 slice C transition from modified to TAG
##720E5
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#191,v,g,n,s,PM_L3SC_REF,L3 slice C references
##701C5
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice.
#192,v,g,n,s,PM_L3SC_SHR_INV,L3 slice C transition from shared to invalid
##710C5
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#193,v,g,n,s,PM_L3SC_SNOOP_RETRY,L3 slice C snoop retries
##731E5
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#194,v,g,n,n,PM_LARX_LSU0,Larx executed on LSU0
##820E7
A larx (lwarx or ldarx) was executed on side 0 (there is no corresponding unit 1 event since larx instructions can only execute on unit 0)
#195,v,g,n,n,PM_LD_MISS_L1,L1 D cache load misses
##C1088
Load references that miss the Level 1 Data cache. Combined unit 0 + 1.
#196,v,g,n,n,PM_LD_MISS_L1_LSU0,LSU0 L1 D cache load misses
##C10C2
Load references that miss the Level 1 Data cache, by unit 0.
#197,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C6
Load references that miss the Level 1 Data cache, by unit 1.
#198,v,g,n,n,PM_LD_REF_L1_LSU0,LSU0 L1 D cache load references
##C10C0
Load references to Level 1 Data Cache, by unit 0.
#199,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C5
Load references that miss the Level 1 Data cache, by unit 1.
#200,u,g,n,s,PM_LR_CTR_MAP_FULL_CYC,Cycles LR/CTR mapper full
##100C6
The LR/CTR mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#201,v,g,n,n,PM_LSU0_BUSY_REJECT,LSU0 busy due to reject
##C20E1
Total cycles the Load Store Unit 0 is busy rejecting instructions.
#202,v,g,n,n,PM_LSU0_DERAT_MISS,LSU0 DERAT misses
##800C2
Total D-ERAT Misses by LSU0.   Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.
#203,v,g,n,n,PM_LSU0_FLUSH_LRQ,LSU0 LRQ flushes
##C00C2
A load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#204,u,g,n,n,PM_LSU0_FLUSH_SRQ,LSU0 SRQ lhs flushes
##C00C3
A store was flushed by unit 0 because younger load hits and older store that is already in the SRQ or in the same group.
#205,v,g,n,n,PM_LSU0_FLUSH_ULD,LSU0 unaligned load flushes
##C00C0
A load was flushed from unit 0 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1)
#206,v,g,n,n,PM_LSU0_FLUSH_UST,LSU0 unaligned store flushes
##C00C1
A store was flushed from unit 0 because it was unaligned (crossed a 4K boundary).
#207,v,g,n,n,PM_LSU0_LDF,LSU0 executed Floating Point load instruction
##C50C0
A floating point load was executed by LSU0
#208,v,g,n,n,PM_LSU0_NCLD,LSU0 non-cacheable loads
##C50C1
A non-cacheable load was executed by unit 0.
#209,v,g,n,n,PM_LSU0_REJECT_ERAT_MISS,LSU0 reject due to ERAT miss
##C40C3
Total cycles the Load Store Unit 0 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#210,v,g,n,n,PM_LSU0_REJECT_LMQ_FULL,LSU0 reject due to LMQ full or missed data coming
##C40C1
Total cycles the Load Store Unit 0 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#211,v,g,n,n,PM_LSU0_REJECT_RELOAD_CDF,LSU0 reject due to reload CDF or tag update collision
##C40C2
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#212,v,g,n,n,PM_LSU0_REJECT_SRQ,LSU0 SRQ lhs rejects
##C40C0
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#213,u,g,n,n,PM_LSU0_SRQ_STFWD,LSU0 SRQ store forwarded
##C60E1
Data from a store instruction was forwarded to a load on unit 0.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#214,v,g,n,n,PM_LSU1_BUSY_REJECT,LSU1 busy due to reject
##C20E5
Total cycles the Load Store Unit 1 is busy rejecting instructions.
#215,v,g,n,n,PM_LSU1_DERAT_MISS,LSU1 DERAT misses
##800C6
A data request (load or store) from LSU Unit 1 missed the ERAT and resulted in an ERAT reload. Multiple instructions may miss the ERAT entry for the same 4K page, but only one reload will occur.
#216,v,g,n,n,PM_LSU1_FLUSH_LRQ,LSU1 LRQ flushes
##C00C6
A load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#217,u,g,n,n,PM_LSU1_FLUSH_SRQ,LSU1 SRQ lhs flushes
##C00C7
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#218,v,g,n,n,PM_LSU1_FLUSH_ULD,LSU1 unaligned load flushes
##C00C4
A load was flushed from unit 1 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1).
#219,u,g,n,n,PM_LSU1_FLUSH_UST,LSU1 unaligned store flushes
##C00C5
A store was flushed from unit 1 because it was unaligned (crossed a 4K boundary)
#220,v,g,n,n,PM_LSU1_LDF,LSU1 executed Floating Point load instruction
##C50C4
A floating point load was executed by LSU1
#221,v,g,n,n,PM_LSU1_NCLD,LSU1 non-cacheable loads
##C50C5
A non-cacheable load was executed by Unit 0.
#222,v,g,n,n,PM_LSU1_REJECT_ERAT_MISS,LSU1 reject due to ERAT miss
##C40C7
Total cycles the Load Store Unit 1 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#223,v,g,n,n,PM_LSU1_REJECT_LMQ_FULL,LSU1 reject due to LMQ full or missed data coming
##C40C5
Total cycles the Load Store Unit 1 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#224,v,g,n,n,PM_LSU1_REJECT_RELOAD_CDF,LSU1 reject due to reload CDF or tag update collision
##C40C6
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#225,v,g,n,n,PM_LSU1_REJECT_SRQ,LSU1 SRQ lhs rejects
##C40C4
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#226,u,g,n,n,PM_LSU1_SRQ_STFWD,LSU1 SRQ store forwarded
##C60E5
Data from a store instruction was forwarded to a load on unit 1.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#227,v,g,n,n,PM_LSU_DERAT_MISS,DERAT misses
##800A8
Total D-ERAT Misses.  Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.  Combined Unit 0 + 1.
#228,v,g,n,n,PM_LSU_FLUSH,Flush initiated by LSU
##110C5
A flush was initiated by the Load Store Unit
#229,v,g,n,n,PM_LSU_FLUSH_LRQ,LRQ flushes
##C00A8
A load was flushed because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.  Combined Units 0 and 1.
#230,v,g,n,s,PM_LSU_FLUSH_LRQ_FULL,Flush caused by LRQ full
##320E7
This thread was flushed at dispatch because its Load Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#231,v,g,n,s,PM_LSU_FLUSH_SRQ_FULL,Flush caused by SRQ full
##330E0
This thread was flushed at dispatch because its Store Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#232,u,g,n,s,PM_LSU_LMQ_FULL_CYC,Cycles LMQ full
##C30E7
The Load Miss Queue was full.
#233,v,g,n,n,PM_LSU_LMQ_LHR_MERGE,LMQ LHR merges
##C70E5
A data cache miss occurred for the same real cache line address as an earlier request already in the Load Miss Queue and was merged into the LMQ entry.
#234,v,g,n,s,PM_LSU_LMQ_S0_ALLOC,LMQ slot 0 allocated
##C30E6
The first entry in the LMQ was allocated.
#235,v,g,n,n,PM_LSU_LMQ_S0_VALID,LMQ slot 0 valid
##C30E5
This signal is asserted every cycle when the first entry in the LMQ is valid. The LMQ had eight entries that are allocated FIFO
#236,u,g,n,n,PM_LSU_LMQ_SRQ_EMPTY_CYC,Cycles LMQ and SRQ empty
##00015
Cycles when both the LMQ and SRQ are empty (LSU is idle)
#237,v,g,n,s,PM_LSU_LRQ_FULL_CYC,Cycles LRQ full
##110C2
Cycles when the LRQ is full.
#238,v,g,n,n,PM_LSU_LRQ_S0_ALLOC,LRQ slot 0 allocated
##C60E7
LRQ slot zero was allocated
#239,v,g,n,n,PM_LSU_LRQ_S0_VALID,LRQ slot 0 valid
##C60E6
This signal is asserted every cycle that the Load Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the LRQ is split between the two threads (16 entries each).
#240,v,g,n,n,PM_LSU_REJECT_RELOAD_CDF,LSU reject due to reload CDF or tag update collision
##C40A8
Total cycles the Load Store Unit is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.  Combined Unit 0 + 1.
#241,v,g,n,s,PM_LSU_SRQ_FULL_CYC,Cycles SRQ full
##110C3
Cycles the Store Request Queue is full.
#242,v,g,n,n,PM_LSU_SRQ_S0_ALLOC,SRQ slot 0 allocated
##C20E7
SRQ Slot zero was allocated
#243,v,g,n,n,PM_LSU_SRQ_S0_VALID,SRQ slot 0 valid
##C20E6
This signal is asserted every cycle that the Store Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the SRQ is split between the two threads (16 entries each).
#244,u,g,n,n,PM_LSU_SRQ_SYNC_CYC,SRQ sync duration
##830E5
Cycles that a sync instruction is active in the Store Request Queue.
#245,v,g,n,n,PM_LWSYNC_HELD,LWSYNC held at dispatch
##130E0
Cycles a LWSYNC instruction was held at dispatch. LWSYNC instructions are held at dispatch until all previous loads are done and all previous stores have issued. LWSYNC enters the Store Request Queue and is sent to the storage subsystem but does not wait for a response.
#246,c,g,n,n,PM_MEM_FAST_PATH_RD_DISP,Fast path memory read dispatched
##731E6
Fast path memory read dispatched
#247,v,g,n,n,PM_MEM_RQ_DISP_Q8to11,Memory read queue dispatched to queues 8-11
##722E6
A memory operation was dispatched to read queue 8,9,10 or 11. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#248,v,g,n,s,PM_MEM_HI_PRIO_WR_CMPL,High priority write completed
##726E6
A memory write,  which was upgraded to high priority, completed.  Writes can be upgraded to high priority to ensure that read traffic does not lock out writes. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#249,v,g,n,s,PM_MEM_NONSPEC_RD_CANCEL,Non speculative memory read cancelled
##711C6
A non-speculative read was cancelled because the combined response indicated it was sourced from aother L2 or L3.   This event is sent from the Memory Controller clock domain and must be scaled accordingly
#250,v,g,n,s,PM_MEM_LO_PRIO_WR_CMPL,Low priority write completed
##736E6
A memory write,  which was not upgraded to high priority, completed.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#251,v,g,n,s,PM_MEM_PWQ_DISP,Memory partial-write queue dispatched
##704C6
Number of Partial Writes dispatched.  The MC provides resources to gather partial cacheline writes (Partial line DMA writes & CI-stores) to up to four different cachelines at a time.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#252,v,g,n,n,PM_MEM_PWQ_DISP_Q2or3,Memory partial-write queue dispatched to Write Queue 2 or 3
##734E6
Memory partial-write queue dispatched to Write Queue 2 or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#253,v,g,n,s,PM_MEM_PW_CMPL,Memory partial-write completed
##724E6
Number of Partial Writes completed.   This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#254,v,g,n,s,PM_MEM_PW_GATH,Memory partial-write gathered
##714C6
Two or more partial-writes have been merged into a single memory write. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#255,v,g,n,n,PM_MEM_RQ_DISP_Q12to15,Memory read queue dispatched to queues 12-15
##732E6
A memory operation was dispatched to read queue 12,13,14 or 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#256,v,g,n,s,PM_MEM_RQ_DISP,Memory read queue dispatched
##701C6
A memory read was dispatched. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#257,v,g,n,n,PM_MEM_RQ_DISP_Q0to3,Memory read queue dispatched to queues 0-3
##702C6
A memory operation was dispatched to read queue 0,1,2, or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#258,v,g,n,n,PM_MEM_RQ_DISP_Q4to7,Memory read queue dispatched to queues 4-7
##712C6
A memory operation was dispatched to read queue 4,5,6 or 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#259,v,g,n,s,PM_MEM_SPEC_RD_CANCEL,Speculative memory read cancelled
##721E6
Speculative memory read cancelled (i.e. cresp = sourced by L2/L3)
#260,v,g,n,n,PM_MEM_WQ_DISP_Q0to7,Memory write queue dispatched to queues 0-7
##723E6
A memory operation was dispatched to a write queue in the range between 0 and 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#261,v,g,n,n,PM_MEM_WQ_DISP_Q8to15,Memory write queue dispatched to queues 8-15
##733E6
A memory operation was dispatched to a write queue in the range between 8 and 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#262,v,g,n,s,PM_MEM_WQ_DISP_DCLAIM,Memory write queue dispatched due to dclaim/flush
##713C6
A memory dclaim or flush operation was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#263,v,g,n,s,PM_MEM_WQ_DISP_WRITE,Memory write queue dispatched due to write
##703C6
A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#264,v,g,n,n,PM_MRK_DATA_FROM_L25_MOD,Marked data loaded from L2.5 modified
##C70A2
The processor's Data Cache was reloaded with modified (M) data from the L2 of a chip on the same module as this processor is located  due to a marked load.
#265,v,g,n,n,PM_MRK_DATA_FROM_L275_SHR,Marked data loaded from L2.75 shared
##C7097
The processor's Data Cache was reloaded with shared (T) data from the L2 on a different module than this processor is located due to a marked load.
#266,v,g,n,n,PM_MRK_DATA_FROM_L2MISS,Marked data loaded missed L2
##C709B
DL1 was reloaded from beyond L2 due to a marked demand load.
#267,v,g,n,n,PM_MRK_DATA_FROM_L3,Marked data loaded from L3
##C70AF
The processor's Data Cache was reloaded from the local L3 due to a marked load.
#268,v,g,n,n,PM_MRK_DATA_FROM_L35_MOD,Marked data loaded from L3.5 modified
##C70A6
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a marked load.
#269,v,g,n,n,PM_MRK_DATA_FROM_L375_SHR,Marked data loaded from L3.75 shared
##C709E
The processor's Data Cache was reloaded with shared (S) data from the L3 of a chip on a different module than this processor is located due to a marked load.
#270,v,g,n,n,PM_MRK_DATA_FROM_LMEM,Marked data loaded from local memory
##C70A0
The processor's Data Cache was reloaded due to a marked load from memory attached to the same module this proccessor is located on.
#271,v,g,n,n,PM_MRK_DSLB_MISS,Marked Data SLB misses
##C50C7
A Data SLB miss was caused by a marked instruction.
#272,v,g,n,n,PM_MRK_DTLB_MISS,Marked Data TLB misses
##C50C6,C60E0
Data TLB references by a marked instruction that missed the TLB (all page sizes).
#273,v,g,n,n,PM_MRK_DTLB_MISS_16M,Marked Data TLB misses for 16M page
##C608D
Marked Data TLB misses for 16M page
#274,v,g,n,n,PM_MRK_DTLB_REF,Marked Data TLB reference
##C60E4
Total number of Data TLB references by a marked instruction for all page sizes. Page size is determined at TLB reload time.
#275,v,g,n,n,PM_MRK_DTLB_REF_16M,Marked Data TLB reference for 16M page
##C6086
Data TLB references by a marked instruction for 16MB pages.
#276,v,g,n,n,PM_MRK_FPU_FIN,Marked instruction FPU processing finished
##00014
One of the Floating Point Units finished a marked instruction. Instructions that finish may not necessary complete
#277,v,g,n,n,PM_MRK_IMR_RELOAD,Marked IMR reloaded
##820E2
A DL1 reload occurred due to marked load
#278,v,g,n,n,PM_MRK_INST_FIN,Marked instruction finished
##00005
One of the execution units finished a marked instruction.  Instructions that finish may not necessary complete
#279,v,g,n,n,PM_MRK_L1_RELOAD_VALID,Marked L1 reload data source valid
##C70E4
The source information is valid and is for a marked load
#280,v,g,n,n,PM_MRK_LD_MISS_L1_LSU0,LSU0 marked L1 D cache load misses
##820E0
Load references that miss the Level 1 Data cache, by LSU0.
#281,v,g,n,n,PM_MRK_LD_MISS_L1_LSU1,LSU1 marked L1 D cache load misses
##820E4
Load references that miss the Level 1 Data cache, by LSU1.
#282,v,g,n,n,PM_MRK_LSU0_FLUSH_LRQ,LSU0 marked LRQ flushes
##810C2
A marked load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#283,u,g,n,n,PM_MRK_LSU0_FLUSH_SRQ,LSU0 marked SRQ lhs flushes
##810C3
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#284,v,g,n,n,PM_MRK_LSU0_FLUSH_ULD,LSU0 marked unaligned load flushes
##810C1
A marked load was flushed from unit 0 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#285,v,g,n,n,PM_MRK_LSU0_FLUSH_UST,LSU0 marked unaligned store flushes
##810C0
A marked store was flushed from unit 0 because it was unaligned
#286,v,g,n,n,PM_MRK_LSU1_FLUSH_LRQ,LSU1 marked LRQ flushes
##810C6
A marked load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#287,u,g,n,n,PM_MRK_LSU1_FLUSH_SRQ,LSU1 marked SRQ lhs flushes
##810C7
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#288,v,g,n,n,PM_MRK_LSU1_FLUSH_ULD,LSU1 marked unaligned load flushes
##810C4
A marked load was flushed from unit 1 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#289,u,g,n,n,PM_MRK_LSU1_FLUSH_UST,LSU1 marked unaligned store flushes
##810C5
A marked store was flushed from unit 1 because it was unaligned (crossed a 4k boundary)
#290,v,g,n,n,PM_MRK_LSU_FLUSH_LRQ,Marked LRQ flushes
##81088
A marked load was flushed because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#291,v,g,n,n,PM_MRK_LSU_FLUSH_UST,Marked unaligned store flushes
##81090
A marked store was flushed because it was unaligned
#292,u,g,n,n,PM_MRK_LSU_SRQ_INST_VALID,Marked instruction valid in SRQ
##C70E6
This signal is asserted every cycle when a marked request is resident in the Store Request Queue
#293,v,g,n,n,PM_MRK_STCX_FAIL,Marked STCX failed
##820E6
A marked stcx (stwcx or stdcx) failed
#294,v,g,n,n,PM_MRK_ST_CMPL_INT,Marked store completed with intervention
##00003
A marked store previously sent to the memory subsystem completed (data home) after requiring intervention
#295,v,g,n,n,PM_MRK_ST_MISS_L1,Marked L1 D cache store misses
##820E3
A marked store missed the dcache
#296,v,g,n,n,PM_PMC2_OVERFLOW,PMC2 Overflow
##0000A
Overflows from PMC2 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#297,v,g,n,n,PM_PMC6_OVERFLOW,PMC6 Overflow
##0001A
Overflows from PMC6 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#298,v,g,n,n,PM_PTEG_FROM_L25_MOD,PTEG loaded from L2.5 modified
##830A2
A Page Table Entry was loaded into the TLB with modified (M) data from the L2 of a chip on the same module as this processor is located due to a demand load.
#299,v,g,n,n,PM_PTEG_FROM_L275_SHR,PTEG loaded from L2.75 shared
##83097
A Page Table Entry was loaded into the TLB with shared (T) data from the L2 on a different module than this processor is located due to a demand load.
#300,v,g,n,n,PM_PTEG_FROM_L2MISS,PTEG loaded from L2 miss
##8309B
A Page Table Entry was loaded into the TLB but not from the local L2.
#301,v,g,n,n,PM_PTEG_FROM_L3,PTEG loaded from L3
##830AF
A Page Table Entry was loaded into the TLB from the local L3 due to a demand load.
#302,v,g,n,n,PM_PTEG_FROM_L35_MOD,PTEG loaded from L3.5 modified
##830A6
A Page Table Entry was loaded into the TLB with modified (M) data from the L3 of a chip on the same module as this processor is located, due to a demand load.
#303,v,g,n,n,PM_PTEG_FROM_L375_SHR,PTEG loaded from L3.75 shared
##8309E
A Page Table Entry  was loaded into the TLB with shared (S) data from the L3 of a chip on a different module than this processor is located, due to a demand load.
#304,v,g,n,n,PM_PTEG_FROM_LMEM,PTEG loaded from local memory
##830A0
A Page Table Entry was loaded into the TLB from memory attached to the same module this proccessor is located on.
#305,v,g,n,n,PM_PTEG_RELOAD_VALID,PTEG reload valid
##830E4
A Page Table Entry was loaded into the TLB.
#306,v,g,n,s,PM_SNOOP_DCLAIM_RETRY_QFULL,Snoop dclaim/flush retry due to write/dclaim queues full
##720E6
The memory controller A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#307,v,g,n,s,PM_SNOOP_PARTIAL_RTRY_QFULL,Snoop partial write retry due to partial-write queues full
##730E6
A snoop request for a partial write to memory was retried because the write queues that handle partial writes were full. When this happens the active writes are changed to high priority. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#308,v,g,n,s,PM_SNOOP_PW_RETRY_RQ,Snoop partial-write retry due to collision with active read queue
##707C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#309,v,g,n,s,PM_SNOOP_PW_RETRY_WQ_PWQ,Snoop partial-write retry due to collision with active write or partial-write queue
##717C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active write or partial write.  When this happens the snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#310,v,g,n,s,PM_SNOOP_RD_RETRY_QFULL,Snoop read retry due to read queue full
##700C6
A snoop request for a read from memory was retried because the read queues were full.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#311,v,g,n,s,PM_SNOOP_RD_RETRY_RQ,Snoop read retry due to collision with active read queue
##705C6
A snoop request for a read from memory was retried because it matched the cache line of an active read.  The snoop request is retried because the L2 may be able to source data via intervention for the 2nd read faster than the MC.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#312,v,g,n,s,PM_SNOOP_RD_RETRY_WQ,Snoop read retry due to collision with active write queue
##715C6
A snoop request for a read from memory was retried because it matched the cache line of an active write. The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#313,v,g,n,s,PM_SNOOP_RETRY_1AHEAD,Snoop retry due to one ahead collision
##725E6
Snoop retry due to one ahead collision
#314,u,g,n,s,PM_SNOOP_TLBIE,Snoop TLBIE
##800C3
A tlbie was snooped from another processor.
#315,v,g,n,s,PM_SNOOP_WR_RETRY_QFULL,Snoop read retry due to read queue full
##710C6
A snoop request for a write to memory was retried because the write queues were full.  When this happens the snoop request is retried and the writes in the write reorder queue are changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#316,v,g,n,s,PM_SNOOP_WR_RETRY_RQ,Snoop write/dclaim retry due to collision with active read queue
##706C6
A snoop request for a write or dclaim to memory was retried because it matched the cacheline of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#317,v,g,n,s,PM_SNOOP_WR_RETRY_WQ,Snoop write/dclaim retry due to collision with active write queue
##716C6
A snoop request for a write or dclaim to memory was retried because it matched the cache line of an active write.  The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#318,v,g,n,n,PM_STCX_FAIL,STCX failed
##820E1
A stcx (stwcx or stdcx) failed
#319,v,g,n,n,PM_STCX_PASS,Stcx passes
##820E5
A stcx (stwcx or stdcx) instruction was successful
#320,v,g,n,n,PM_STOP_COMPLETION,Completion stopped
##00018
RAS Unit has signaled completion to stop
#321,v,g,n,n,PM_ST_MISS_L1,L1 D cache store misses
##C10C3
A store missed the dcache.  Combined Unit 0 + 1.
#322,v,g,n,n,PM_ST_REF_L1,L1 D cache store references
##C1090
Store references to the Data Cache. Combined Unit 0 + 1.
#323,v,g,n,n,PM_ST_REF_L1_LSU0,LSU0 L1 D cache store references
##C10C1
Store references to the Data Cache by LSU0.
#324,v,g,n,n,PM_ST_REF_L1_LSU1,LSU1 L1 D cache store references
##C10C4
Store references to the Data Cache by LSU1.
#325,v,g,n,n,PM_SUSPENDED,Suspended
##00000
The counter is suspended (does not count).
#326,v,g,n,s,PM_THRD_L2MISS_BOTH_CYC,Cycles both threads in L2 misses
##410C7
Cycles that both threads have L2 miss pending.  If only one thread has a L2 miss pending the other thread is given priority at decode.  If both threads have L2 miss pending decode priority is determined by the number of GCT entries used.
#327,v,g,n,n,PM_THRD_PRIO_1_CYC,Cycles thread running at priority level 1
##420E0
Cycles this thread was running at priority level 1. Priority level 1 is the lowest and indicates the thread is sleeping.
#328,v,g,n,n,PM_THRD_PRIO_2_CYC,Cycles thread running at priority level 2
##420E1
Cycles this thread was running at priority level 2.
#329,v,g,n,n,PM_THRD_PRIO_3_CYC,Cycles thread running at priority level 3
##420E2
Cycles this thread was running at priority level 3.
#330,v,g,n,n,PM_THRD_PRIO_4_CYC,Cycles thread running at priority level 4
##420E3
Cycles this thread was running at priority level 4.
#331,v,g,n,n,PM_THRD_PRIO_5_CYC,Cycles thread running at priority level 5
##420E4
Cycles this thread was running at priority level 5.
#332,v,g,n,n,PM_THRD_PRIO_6_CYC,Cycles thread running at priority level 6
##420E5
Cycles this thread was running at priority level 6.
#333,v,g,n,n,PM_THRD_PRIO_7_CYC,Cycles thread running at priority level 7
##420E6
Cycles this thread was running at priority level 7.
#334,v,g,n,n,PM_THRD_PRIO_DIFF_0_CYC,Cycles no thread priority difference
##430E3
Cycles when this thread's priority is equal to the other thread's priority.
#335,v,g,n,n,PM_THRD_PRIO_DIFF_1or2_CYC,Cycles thread priority difference is 1 or 2
##430E4
Cycles when this thread's priority is higher than the other thread's priority by 1 or 2.
#336,v,g,n,n,PM_THRD_PRIO_DIFF_3or4_CYC,Cycles thread priority difference is 3 or 4
##430E5
Cycles when this thread's priority is higher than the other thread's priority by 3 or 4.
#337,v,g,n,n,PM_THRD_PRIO_DIFF_5or6_CYC,Cycles thread priority difference is 5 or 6
##430E6
Cycles when this thread's priority is higher than the other thread's priority by 5 or 6.
#338,v,g,n,n,PM_THRD_PRIO_DIFF_minus1or2_CYC,Cycles thread priority difference is -1 or -2
##430E2
Cycles when this thread's priority is lower than the other thread's priority by 1 or 2.
#339,v,g,n,n,PM_THRD_PRIO_DIFF_minus3or4_CYC,Cycles thread priority difference is -3 or -4
##430E1
Cycles when this thread's priority is lower than the other thread's priority by 3 or 4.
#340,v,g,n,n,PM_THRD_PRIO_DIFF_minus5or6_CYC,Cycles thread priority difference is -5 or -6
##430E0
Cycles when this thread's priority is lower than the other thread's priority by 5 or 6.
#341,v,g,n,s,PM_THRD_SEL_OVER_CLB_EMPTY,Thread selection overrides caused by CLB empty
##410C2
Thread selection was overridden because one thread's CLB was empty.
#342,v,g,n,s,PM_THRD_SEL_OVER_GCT_IMBAL,Thread selection overrides caused by GCT imbalance
##410C4
Thread selection was overridden because of a GCT imbalance.
#343,v,g,n,s,PM_THRD_SEL_OVER_ISU_HOLD,Thread selection overrides caused by ISU holds
##410C5
Thread selection was overridden because of an ISU hold.
#344,v,g,n,s,PM_THRD_SEL_OVER_L2MISS,Thread selection overrides caused by L2 misses
##410C3
Thread selection was overridden because one thread was had a L2 miss pending.
#345,v,g,n,s,PM_THRD_SEL_T0,Decode selected thread 0
##410C0
Thread selection picked thread 0 for decode.
#346,v,g,n,s,PM_THRD_SEL_T1,Decode selected thread 1
##410C1
Thread selection picked thread 1 for decode.
#347,v,g,n,s,PM_THRD_SMT_HANG,SMT hang detected
##330E7
A hung thread was detected
#348,v,g,t,n,PM_THRESH_TIMEO,Threshold timeout
##0000B
The threshold timer expired
#349,v,g,n,n,PM_TLBIE_HELD,TLBIE held at dispatch
##130E4
Cycles a TLBIE instruction was held at dispatch.
#350,v,g,n,s,PM_XER_MAP_FULL_CYC,Cycles XER mapper full
##100C2
The XER mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#351,v,g,n,n,PM_BR_PRED_TA,A conditional branch was predicted, target prediction
##230E3
The target address of a branch instruction was predicted.
#352,v,g,n,n,PM_MEM_RQ_DISP_Q16to19,Memory read queue dispatched to queues 16-19
##727E6
A memory operation was dispatched to read queue 16,17,18 or 19. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#353,v,g,n,n,PM_SNOOP_RETRY_AB_COLLISION,Snoop retry due to a b collision
##735E6
Snoop retry due to a b collision
#354,v,g,n,n,PM_INST_DISP_ATTEMPT,Instructions dispatch attempted
##120E1
Number of PowerPC Instructions dispatched (attempted, not filtered by success.

$$$$$$$$

{ counter 4 }
#0,v,g,n,n,PM_0INST_CLB_CYC,Cycles no instructions in CLB
##400C0
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#1,v,g,n,n,PM_0INST_FETCH,No instructions fetched
##2208D
No instructions were fetched this cycles (due to IFU hold, redirect, or icache miss)
#2,v,g,n,n,PM_1INST_CLB_CYC,Cycles 1 instruction in CLB
##400C1
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#3,v,g,n,n,PM_2INST_CLB_CYC,Cycles 2 instructions in CLB
##400C2
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#4,v,g,n,n,PM_3INST_CLB_CYC,Cycles 3 instructions in CLB
##400C3
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#5,v,g,n,n,PM_4INST_CLB_CYC,Cycles 4 instructions in CLB
##400C4
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#6,v,g,n,n,PM_5INST_CLB_CYC,Cycles 5 instructions in CLB
##400C5
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#7,v,g,n,n,PM_6INST_CLB_CYC,Cycles 6 instructions in CLB
##400C6
The cache line buffer (CLB) is a 6-deep, 4-wide instruction buffer. Fullness is reported on a cycle basis with each event representing the number of cycles the CLB had the corresponding number of entries occupied.  These events give a real time history of the number of instruction buffers used, but not the number of PowerPC instructions within those buffers.  Each thread has its own set of CLB; these events are thread specific.
#8,u,g,n,s,PM_BRQ_FULL_CYC,Cycles branch queue full
##100C5
Cycles when the issue queue that feeds the branch unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#9,v,g,n,n,PM_BR_ISSUED,Branches issued
##230E4
A branch instruction was issued to the branch unit.  A branch that was incorrectly predicted may issue and execute multiple times.
#10,v,g,n,n,PM_BR_MPRED_CR,Branch mispredictions due to CR bit setting
##230E5
A conditional branch instruction was incorrectly predicted as taken or not taken.  The branch execution unit detects a branch mispredict because the CR value is opposite of the predicted value. This will result in a branch redirect flush if not overfidden by a flush of an older instruction.
#11,v,g,n,n,PM_BR_MPRED_TA,Branch mispredictions due to target address
##230E6
A branch instruction target was incorrectly predicted. This will result in a branch mispredict flush unless a flush is detected from an older instruction.
#12,v,g,n,n,PM_BR_PRED_CR_TA,A conditional branch was predicted, CR and target prediction
##23087
Both the condition (taken or not taken) and the target address of a branch instruction was predicted.
#13,v,g,n,s,PM_CLB_EMPTY_CYC,Cycles CLB empty
##410C6
Cycles when both thread's CLB is completely empty.
#14,v,g,n,n,PM_CLB_FULL_CYC,Cycles CLB full
##220E5
Cycles when both thread's CLB is full.
#15,v,g,n,n,PM_CMPLU_STALL_DIV,Completion stall caused by DIV instruction
##11099
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes was a fixed point divide instruction. This is a subset of PM_CMPLU_STALL_FXU.
#16,v,g,n,n,PM_CMPLU_STALL_ERAT_MISS,Completion stall caused by ERAT miss
##1109B
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes suffered an ERAT miss. This is a subset of  PM_CMPLU_STALL_REJECT.
#17,v,g,n,n,PM_CMPLU_STALL_FPU,Completion stall caused by FPU instruction
##11098
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes was a floating point instruction.
#18,v,g,n,n,PM_CMPLU_STALL_REJECT,Completion stall caused by reject
##1109A
Following a completion stall (any period when no groups completed) the last instruction to finish before completion resumes suffered a load/store reject. This is a subset of PM_CMPLU_STALL_LSU.
#19,u,g,n,s,PM_CRQ_FULL_CYC,Cycles CR issue queue full
##110C1
The issue queue that feeds the Conditional Register unit is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#20,v,g,n,s,PM_CR_MAP_FULL_CYC,Cycles CR logical operation mapper full
##100C4
The Conditional Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#21,v,g,n,s,PM_CYC,Processor cycles
##0000F
Processor cycles
#22,v,g,n,n,PM_DATA_FROM_L275_MOD,Data loaded from L2.75 modified
##C3097
The processor's Data Cache was reloaded with modified (M) data from the L2 on a different module than this processor is located due to a demand load.
#23,v,g,n,n,PM_DATA_FROM_L375_MOD,Data loaded from L3.75 modified
##C309E
The processor's Data Cache was reloaded with modified (M) data from the L3 of a chip on the same module as this processor is located due to a demand load.
#24,v,g,n,n,PM_DATA_FROM_RMEM,Data loaded from remote memory
##C3087
The processor's Data Cache was reloaded from memory attached to a different module than this proccessor is located on.
#25,v,g,n,n,PM_DATA_TABLEWALK_CYC,Cycles doing data tablewalks
##800C7
Cycles a translation tablewalk is active.  While a tablewalk is active any request attempting to access the TLB will be rejected and retried.
#26,u,g,n,s,PM_DC_INV_L2,L1 D cache entries invalidated from L2
##C10C7
A dcache invalidated was received from the L2 because a line in L2 was castout.
#27,v,g,n,n,PM_DC_PREF_OUT_OF_STREAMS,D cache out of prefetch streams
##C50C2
A new prefetch stream was detected but no more stream entries were available.
#28,v,g,n,n,PM_DC_PREF_DST,DST (Data Stream Touch) stream start
##830E6
A prefetch stream was started using the DST instruction.
#29,v,g,n,n,PM_DC_PREF_STREAM_ALLOC,D cache new prefetch stream allocated
##830E7
A new Prefetch Stream was allocated.
#30,v,g,n,n,PM_DSLB_MISS,Data SLB misses
##800C5
A SLB miss for a data request occurred. SLB misses trap to the operating system to resolve.
#31,v,g,n,n,PM_DTLB_MISS,Data TLB misses
##800C4,C20E0
Data TLB misses, all page sizes.
#32,v,g,n,n,PM_DTLB_MISS_16G,Data TLB miss for 16G page
##C208D
Data TLB references to 16GB pages that missed the TLB. Page size is determined at TLB reload time.
#33,v,g,n,n,PM_DTLB_REF,Data TLB references
##C20E4
Total number of Data TLB references for all page sizes. Page size is determined at TLB reload time.
#34,v,g,n,n,PM_DTLB_REF_16G,Data TLB reference for 16G page
##C2086
Data TLB references for 16GB pages. Includes hits + misses.
#35,v,g,n,n,PM_EE_OFF,Cycles MSR(EE) bit off
##130E3
Cycles MSR(EE) bit was off indicating that interrupts due to external exceptions were masked.
#36,u,g,n,n,PM_EE_OFF_EXT_INT,Cycles MSR(EE) bit off and external interrupt pending
##130E7
Cycles when an interrupt due to an external exception is pending but external exceptions were masked.
#37,v,g,n,n,PM_EXT_INT,External interrupts
##00003
An interrupt due to an external exception occurred
#38,v,g,n,s,PM_FAB_CMD_ISSUED,Fabric command issued
##700C7
Incremented when a chip issues a command on its SnoopA address bus. Each of the two address busses (SnoopA and SnoopB) is capable of one transaction per fabric cycle (one fabric cycle = 2 cpu cycles in normal 2:1 mode), but each chip can only drive the SnoopA bus, and can only drive one transaction every two fabric cycles (i.e., every four cpu cycles). In MCM-based systems, two chips interleave their accesses to each of the two fabric busses (SnoopA, SnoopB) to reach a peak capability of one transaction per cpu clock cycle. The two chips that drive SnoopB are wired so that the chips refer to the bus as SnoopA but it is connected to the other two chips as SnoopB.  Note that this event will only be recorded by the FBC on the chip that sourced the operation. The signal is delivered at FBC speed and the count must be scaled.
#39,v,g,n,n,PM_FAB_CMD_RETRIED,Fabric command retried
##710C7
Incremented when a command issued by a chip on its SnoopA address bus is retried for any reason. The overwhelming majority of retries are due to running out of memory controller queues but retries can also be caused by trying to reference addresses that are in a transient cache state -- e.g. a line is transient after issuing a DCLAIM instruction to a shared line but before the associated store completes.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#40,v,g,n,s,PM_FAB_DCLAIM_ISSUED,dclaim issued
##720E7
A DCLAIM command was issued. Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#41,v,g,n,s,PM_FAB_DCLAIM_RETRIED,dclaim retried
##730E7
A DCLAIM command was retried.  Each chip reports its own counts.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#42,v,g,n,s,PM_FAB_HOLDtoNN_EMPTY,Hold buffer to NN empty
##722E7
Fabric cyles when the Next Node out hold-buffers are emtpy.  The signal is delivered at FBC speed and the count must be scaled accordingly.
#43,v,g,n,s,PM_FAB_HOLDtoVN_EMPTY,Hold buffer to VN empty
##721E7
Fabric cycles when the Vertical Node out hold-buffers are emtpy. The signal is delivered at FBC speed and the count must be scaled accordingly.
#44,v,g,n,s,PM_FAB_M1toP1_SIDECAR_EMPTY,M1 to P1 sidecar empty
##702C7
Fabric cycles when the Minus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#45,v,g,n,s,PM_FAB_M1toVNorNN_SIDECAR_EMPTY,M1 to VN/NN sidecar empty
##712C7
Fabric cycles when the Minus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#46,v,g,n,s,PM_FAB_P1toM1_SIDECAR_EMPTY,P1 to M1 sidecar empty
##701C7
Fabric cycles when the Plus-1 hip/hop sidecars (sidecars for chip to chip data transfer) are empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#47,v,g,n,s,PM_FAB_P1toVNorNN_SIDECAR_EMPTY,P1 to VN/NN sidecar empty
##711C7
Fabric cycles when the Plus-1 jump sidecar (sidecars for mcm to mcm data transfer) is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#48,v,g,n,s,PM_FAB_PNtoNN_DIRECT,PN to NN beat went straight to its destination
##703C7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound NN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled.
#49,v,g,n,s,PM_FAB_PNtoNN_SIDECAR,PN to NN beat went to sidecar first
##713C7
Fabric Data beats that the base chip takes the inbound PN data and forwards it on to the outbound NN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled.
#50,v,g,n,s,PM_FAB_PNtoVN_DIRECT,PN to VN beat went straight to its destination
##723E7
Fabric Data beats that the base chip takes the inbound PN data and passes it through to the outbound VN bus without going into a sidecar. The signal is delivered at FBC speed and the count must be scaled accordingly.
#51,v,g,n,s,PM_FAB_PNtoVN_SIDECAR,PN to VN beat went to sidecar first
##733E7
Fabric data beats that the base chip takes the inbound PN data and forwards it on to the outbound VN data bus after going into a sidecar first. The signal is delivered at FBC speed and the count must be scaled accordingly.
#52,v,g,n,s,PM_FAB_VBYPASS_EMPTY,Vertical bypass buffer empty
##731E7
Fabric cycles when the Middle Bypass sidecar is empty. The signal is delivered at FBC speed and the count must be scaled accordingly.
#53,v,g,n,n,PM_FLUSH,Flushes
##110C7
Flushes occurred including LSU and Branch flushes.
#54,v,g,n,n,PM_FLUSH_BR_MPRED,Flush caused by branch mispredict
##110C6
A flush was caused by a branch mispredict.
#55,v,g,n,s,PM_FLUSH_IMBAL,Flush caused by thread GCT imbalance
##330E3
This thread has been flushed at dispatch because it is stalled and a GCT imbalance exists.  GCT thresholds are set in the TSCR register. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#56,v,g,n,s,PM_FLUSH_SB,Flush caused by scoreboard operation
##330E2
This thread has been flushed at dispatch because its scoreboard bit is set indicating that a non-renamed resource is being updated. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#57,v,g,n,s,PM_FLUSH_SYNC,Flush caused by sync
##330E1
This thread has been flushed at dispatch due to a sync, lwsync, ptesync, or tlbsync instruction.  This allows the other thread to have more machine resources for it to make progress until the sync finishes.
#58,v,g,n,s,PM_FPR_MAP_FULL_CYC,Cycles FPR mapper full
##100C1
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#59,v,g,n,n,PM_FPU0_1FLOP,FPU0 executed add, mult, sub, cmp or sel instruction
##000C3
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#60,v,g,n,n,PM_FPU0_DENORM,FPU0 received denormalized data
##020E0
FPU0 has encountered a denormalized operand.
#61,v,g,n,n,PM_FPU0_FDIV,FPU0 executed FDIV instruction
##000C0
FPU0 has executed a divide instruction. This could be fdiv, fdivs, fdiv. fdivs.
#62,v,g,n,n,PM_FPU0_FEST,FPU0 executed FEST instruction
##010C2
FPU0 has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#63,v,g,n,n,PM_FPU0_FIN,FPU0 produced a result
##010C3
FPU0 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads.
#64,v,g,n,n,PM_FPU0_FMA,FPU0 executed multiply-add instruction
##000C1
The floating point unit has executed a multiply-add kind of instruction.  This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#65,v,g,n,n,PM_FPU0_FMOV_FEST,FPU0 executed FMOV or FEST instructions
##010C0
FPU0 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#66,v,g,n,n,PM_FPU0_FPSCR,FPU0 executed FPSCR instruction
##030E0
FPU0 has executed FPSCR move related instruction. This could be mtfsfi*, mtfsb0*, mtfsb1*, mffs*, mtfsf*, mcrsf* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#67,v,g,n,n,PM_FPU0_FRSP_FCONV,FPU0 executed FRSP or FCONV instructions
##010C1
FPU0 has executed a frsp or convert kind of instruction. This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#68,v,g,n,n,PM_FPU0_FSQRT,FPU0 executed FSQRT instruction
##000C2
FPU0 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#69,v,g,n,s,PM_FPU0_FULL_CYC,Cycles FPU0 issue queue full
##100C3
The issue queue for FPU0 cannot accept any more instruction. Dispatch to this issue queue is stopped.
#70,v,g,n,n,PM_FPU0_SINGLE,FPU0 executed single precision instruction
##020E3
FPU0 has executed a single precision instruction.
#71,v,g,n,n,PM_FPU0_STALL3,FPU0 stalled in pipe3
##020E1
FPU0 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#72,v,g,n,n,PM_FPU0_STF,FPU0 executed store instruction
##020E2
FPU0 has executed a Floating Point Store instruction.
#73,v,g,n,n,PM_FPU1_1FLOP,FPU1 executed add, mult, sub, cmp or sel instruction
##000C7
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#74,v,g,n,n,PM_FPU1_DENORM,FPU1 received denormalized data
##020E4
FPU1 has encountered a denormalized operand.
#75,v,g,n,n,PM_FPU1_FDIV,FPU1 executed FDIV instruction
##000C4
FPU1 has executed a divide instruction.  This could be fdiv, fdivs, fdiv. fdivs.
#76,v,g,n,n,PM_FPU1_FEST,FPU1 executed FEST instruction
##010C6
FPU1 has executed an estimate instructions.  This could be fres* or frsqrte* where XYZ* means XYZ or XYZ.
#77,v,g,n,n,PM_FPU1_FIN,FPU1 produced a result
##010C7
FPU1 finished, produced a result.  This only indicates finish,  not completion. Floating Point Stores are included in this count but not Floating Point Loads., ,
#78,v,g,n,n,PM_FPU1_FMA,FPU1 executed multiply-add instruction
##000C5
The floating point unit has executed a multiply-add kind of instruction. This could be fmadd*, fnmadd*, fmsub*, fnmsub* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#79,v,g,n,n,PM_FPU1_FMOV_FEST,FPU1 executed FMOV or FEST instructions
##010C4
FPU1 has executed a move kind of instruction or one of the estimate instructions.  This could be fmr*, fneg*, fabs*, fnabs* , fres* or frsqrte* where XYZ* means XYZ or XYZ.
#80,v,g,n,n,PM_FPU1_FRSP_FCONV,FPU1 executed FRSP or FCONV instructions
##010C5
FPU1 has executed a frsp or convert kind of instruction.  This could be frsp*, fcfid*, fcti* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#81,v,g,n,n,PM_FPU1_FSQRT,FPU1 executed FSQRT instruction
##000C6
FPU1 has executed a square root instruction. This could be fsqrt* where XYZ* means XYZ, XYZs, XYZ., XYZs.
#82,v,g,n,s,PM_FPU1_FULL_CYC,Cycles FPU1 issue queue full
##100C7
The issue queue for FPU1 cannot accept any more instructions. Dispatch to this issue queue is stopped
#83,v,g,n,n,PM_FPU1_SINGLE,FPU1 executed single precision instruction
##020E7
FPU1 has executed a single precision instruction.
#84,v,g,n,n,PM_FPU1_STALL3,FPU1 stalled in pipe3
##020E5
FPU1 has generated a stall in pipe3 due to overflow, underflow, massive cancel, convert to integer (sometimes), or convert from integer (always).
#85,v,g,n,n,PM_FPU1_STF,FPU1 executed store instruction
##020E6
FPU1 has executed a Floating Point Store instruction.
#86,v,g,n,n,PM_FPU_1FLOP,FPU executed one flop instruction
##000A8
The floating point unit has executed an add, mult, sub, compare, fsel, fneg, fabs, fnabs, fres, or frsqrte kind of instruction.  These are single FLOP operations.
#87,v,g,n,n,PM_FPU_FEST,FPU executed FEST instruction
##01090
The floating point unit has executed an estimate instructions. This could be fres* or frsqrte* where XYZ* means XYZ or  XYZ.   Combined Unit 0 + Unit 1.
#88,v,g,n,n,PM_FPU_FIN,FPU produced a result
##01088
FPU finished, produced a result.  This only indicates finish,  not completion. Combined Unit 0 + Unit 1.  Floating Point Stores are included in this count but not Floating Point Loads., , , XYZs
#89,c,g,n,n,PM_FPU_FULL_CYC,Cycles FPU issue queue full
##100A8
Cycles when one or both FPU issue queues are full.  Combined Unit 0 + 1.  Use with caution since this is the sum of cycles when Unit 0 was full plus Unit 1 full.  It does not indicate when both units were full.
#90,v,g,n,n,PM_FPU_SINGLE,FPU executed single precision instruction
##020A8
FPU is executing single precision instruction. Combined Unit 0 + Unit 1.
#91,v,g,n,s,PM_FXLS0_FULL_CYC,Cycles FXU0/LS0 queue full
##110C0
The issue queue that feeds the Fixed Point unit 0 / Load Store Unit 0 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#92,v,g,n,s,PM_FXLS1_FULL_CYC,Cycles FXU1/LS1 queue full
##110C4
The issue queue that feeds the Fixed Point unit 1 / Load Store Unit 1 is full. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the queue was full, not that dispatch was prevented.
#93,c,g,n,n,PM_FXLS_FULL_CYC,Cycles FXLS queue is full
##11090
Cycles when the issue queues for one or both FXU/LSU units is full.  Use with caution since this is the sum of cycles when Unit 0 was full plus Unit 1 full.  It does not indicate when both units were full.
#94,v,g,n,n,PM_FXU0_FIN,FXU0 produced a result
##130E2
The Fixed Point unit 0 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#95,u,g,n,n,PM_FXU1_BUSY_FXU0_IDLE,FXU1 busy FXU0 idle
##00012
FXU0 was idle while FXU1 was busy.
#96,v,g,n,n,PM_FXU1_FIN,FXU1 produced a result
##130E6
The Fixed Point unit 1 finished an instruction and produced a result.  Instructions that finish may not necessary complete.
#97,v,g,n,n,PM_GCT_FULL_CYC,Cycles GCT full
##0001F,100C0
The Global Completion Table is completely full.
#98,v,g,n,n,PM_GCT_NOSLOT_BR_MPRED,No slot in GCT caused by branch mispredict
##1009C
Cycles when the Global Completion Table has no slots from this thread because of a branch misprediction.
#99,v,g,n,s,PM_GPR_MAP_FULL_CYC,Cycles GPR mapper full
##130E5
The General Purpose Register mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#100,v,g,n,n,PM_GRP_BR_REDIR,Group experienced branch redirect
##120E6
Number of groups, counted at dispatch, that have encountered a branch redirect.  Every group constructed from a fetch group that has been redirected will count.
#101,c,g,n,n,PM_GRP_IC_MISS_BR_REDIR_NONSPEC,Group experienced non-speculative I cache miss or branch redirect
##120E5
Group experienced non-speculative I cache miss or branch redirect
#102,v,g,n,n,PM_GRP_DISP_BLK_SB_CYC,Cycles group dispatch blocked by scoreboard
##130E1
A scoreboard operation on a non-renamed resource has blocked dispatch.
#103,v,g,n,n,PM_GRP_DISP_REJECT,Group dispatch rejected
##00002,120E4
A group that previously attempted dispatch was rejected.
#104,v,g,n,n,PM_GRP_DISP_VALID,Group dispatch valid
##120E3
A group is available for dispatch.  This does not mean it was successfully dispatched.
#105,v,g,n,n,PM_GRP_IC_MISS,Group experienced I cache miss
##120E7
Number of groups, counted at dispatch, that have encountered an icache miss redirect.  Every group constructed from a fetch group that missed the instruction cache will count.
#106,v,g,n,n,PM_IC_DEMAND_L2_BHT_REDIRECT,L2 I cache demand request due to BHT redirect
##230E0
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (CR mispredict).
#107,v,g,n,n,PM_IC_DEMAND_L2_BR_REDIRECT,L2 I cache demand request due to branch redirect
##230E1
A demand (not prefetch) miss to the instruction cache was sent to the L2 as a result of a branch prediction redirect (either ALL mispredicted or Target).
#108,v,g,n,n,PM_IC_PREF_INSTALL,Instruction prefetched installed in prefetch buffer
##210C7
A prefetch buffer entry (line) is allocated but the request is not a demand fetch.
#109,v,g,n,n,PM_IC_PREF_REQ,Instruction prefetch requests
##220E6
An instruction prefetch request has been made.
#110,v,g,n,n,PM_IERAT_XLATE_WR,Translation written to ierat
##220E7
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#111,v,g,n,n,PM_IERAT_XLATE_WR_LP,Large page translation written to ierat
##210C6
An entry was written into the IERAT as a result of an IERAT miss.  This event can be used to count IERAT misses.  An ERAT miss that are later ignored will not be counted unless the ERAT is written before the instruction stream is changed.
#112,v,g,n,n,PM_IOPS_CMPL,Internal operations completed
##00001
Number of internal operations that completed.
#113,v,g,n,n,PM_INST_DISP,Instructions dispatched
##00009
Number of PowerPC instructions successfully dispatched.
#114,v,g,n,n,PM_INST_FETCH_CYC,Cycles at least 1 instruction fetched
##220E4
Cycles when at least one instruction was sent from the fetch unit to the decode unit.
#115,v,g,n,n,PM_INST_FROM_L275_MOD,Instruction fetched from L2.75 modified
##22096
An instruction fetch group was fetched with modified (M) data from the L2 on a different module than this processor is located.  Fetch groups can contain up to 8 instructions
#116,v,g,n,n,PM_INST_FROM_L375_MOD,Instruction fetched from L3.75 modified
##2209D
An instruction fetch group was fetched with modified  (M) data from the L3 of a chip on a different module than this processor is located. Fetch groups can contain up to 8 instructions
#117,v,g,n,n,PM_INST_FROM_RMEM,Instruction fetched from remote memory
##22086
An instruction fetch group was fetched from memory attached to a different module than this proccessor is located on.  Fetch groups can contain up to 8 instructions
#118,u,g,n,n,PM_ISLB_MISS,Instruction SLB misses
##800C1
A SLB miss for an instruction fetch as occurred
#119,v,g,n,n,PM_ITLB_MISS,Instruction TLB misses
##800C0
A TLB miss for an Instruction Fetch has occurred
#120,v,g,n,n,PM_L1_DCACHE_RELOAD_VALID,L1 reload data source valid
##C30E4
The data source information is valid,the data cache has been reloaded.  Prior to POWER5+ this included data cache reloads due to prefetch activity.  With POWER5+ this now only includes reloads due to demand loads.
#121,v,g,n,n,PM_L1_PREF,L1 cache data prefetches
##C70E7
A request to prefetch data into the L1 was made
#122,v,g,n,n,PM_L1_WRITE_CYC,Cycles writing to instruction L1
##230E7
Cycles that a cache line was written to the instruction cache.
#123,v,g,n,s,PM_L2SA_MOD_INV,L2 slice A transition from modified to invalid
##730E0
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#124,v,g,n,s,PM_L2SA_MOD_TAG,L2 slice A transition from modified to tagged
##720E0
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#125,v,g,n,s,PM_L2SA_RCLD_DISP,L2 slice A RC load dispatch attempt
##701C0
A Read/Claim dispatch for a Load was attempted
#126,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_ADDR,L2 slice A RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C0
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#127,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_OTHER,L2 slice A RC load dispatch attempt failed due to other reasons
##731E0
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#128,v,g,n,s,PM_L2SA_RCLD_DISP_FAIL_RC_FULL,L2 slice A RC load dispatch attempt failed due to all RC full
##721E0
A Read/Claim dispatch for a load failed because all RC machines are busy.
#129,v,g,n,s,PM_L2SA_RCST_DISP,L2 slice A RC store dispatch attempt
##702C0
A Read/Claim dispatch for a Store was attempted.
#130,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_ADDR,L2 slice A RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C0
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#131,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_OTHER,L2 slice A RC store dispatch attempt failed due to other reasons
##732E0
A Read/Claim dispatch for a store failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#132,v,g,n,s,PM_L2SA_RCST_DISP_FAIL_RC_FULL,L2 slice A RC store dispatch attempt failed due to all RC full
##722E0
A Read/Claim dispatch for a store failed because all RC machines are busy.
#133,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY,L2 slice A RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C0
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#134,v,g,n,s,PM_L2SA_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice A RC dispatch attempt failed due to all CO busy
##713C0
A Read/Claim dispatch was rejected because all Castout machines were busy.
#135,v,g,n,s,PM_L2SA_SHR_INV,L2 slice A transition from shared to invalid
##710C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#136,v,g,n,s,PM_L2SA_SHR_MOD,L2 slice A transition from shared to modified
##700C0
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#137,v,g,n,n,PM_L2SA_ST_HIT,L2 slice A store hits
##733E0
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B, and C.
#138,v,g,n,n,PM_L2SA_ST_REQ,L2 slice A store requests
##723E0
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#139,v,g,n,s,PM_L2SB_MOD_INV,L2 slice B transition from modified to invalid
##730E1
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#140,v,g,n,s,PM_L2SB_MOD_TAG,L2 slice B transition from modified to tagged
##720E1
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#141,v,g,n,s,PM_L2SB_RCLD_DISP,L2 slice B RC load dispatch attempt
##701C1
A Read/Claim dispatch for a Load was attempted
#142,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_ADDR,L2 slice B RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C1
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#143,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_OTHER,L2 slice B RC load dispatch attempt failed due to other reasons
##731E1
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#144,v,g,n,s,PM_L2SB_RCLD_DISP_FAIL_RC_FULL,L2 slice B RC load dispatch attempt failed due to all RC full
##721E1
A Read/Claim dispatch for a load failed because all RC machines are busy.
#145,v,g,n,s,PM_L2SB_RCST_DISP,L2 slice B RC store dispatch attempt
##702C1
A Read/Claim dispatch for a Store was attempted.
#146,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_ADDR,L2 slice B RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C1
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#147,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_OTHER,L2 slice B RC store dispatch attempt failed due to other reasons
##732E1
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#148,v,g,n,s,PM_L2SB_RCST_DISP_FAIL_RC_FULL,L2 slice B RC store dispatch attempt failed due to all RC full
##722E2
A Read/Claim dispatch for a store failed because all RC machines are busy.
#149,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY,L2 slice B RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C1
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#150,v,g,n,s,PM_L2SB_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice B RC dispatch attempt failed due to all CO busy
##713C1
A Read/Claim dispatch was rejected because all Castout machines were busy.
#151,v,g,n,s,PM_L2SB_SHR_INV,L2 slice B transition from shared to invalid
##710C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#152,v,g,n,s,PM_L2SB_SHR_MOD,L2 slice B transition from shared to modified
##700C1
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#153,v,g,n,n,PM_L2SB_ST_HIT,L2 slice B store hits
##733E1
A store request made from the core hit in the L2 directory.  This event is provided on each of the three L2 slices A, B and C.
#154,v,g,n,n,PM_L2SB_ST_REQ,L2 slice B store requests
##723E1
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#155,v,g,n,s,PM_L2SC_MOD_INV,L2 slice C transition from modified to invalid
##730E2
A cache line in the local L2 directory made a state transition from the Modified state to the Invalid state. This transition was caused by any RWITM snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#156,v,g,n,s,PM_L2SC_MOD_TAG,L2 slice C transition from modified to tagged
##720E2
A cache line in the local L2 directory made a state transition from the Modified state to the Tagged state. This transition was caused by a read snoop request that hit against a modified entry in the local L2. The event is provided on each of the three slices A, B, and C.
#157,v,g,n,s,PM_L2SC_RCLD_DISP,L2 slice C RC load dispatch attempt
##701C2
A Read/Claim dispatch for a Load was attempted
#158,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_ADDR,L2 slice C RC load dispatch attempt failed due to address collision with RC/CO/SN/SQ
##711C2
A Read/Claim dispatch for a load failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#159,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_OTHER,L2 slice C RC load dispatch attempt failed due to other reasons
##731E2
A Read/Claim dispatch for a load failed for some reason other than Full or Collision conditions.
#160,v,g,n,s,PM_L2SC_RCLD_DISP_FAIL_RC_FULL,L2 slice C RC load dispatch attempt failed due to all RC full
##721E2
A Read/Claim dispatch for a load failed because all RC machines are busy.
#161,v,g,n,s,PM_L2SC_RCST_DISP,L2 slice C RC store dispatch attempt
##702C2
A Read/Claim dispatch for a Store was attempted.
#162,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_ADDR,L2 slice C RC store dispatch attempt failed due to address collision with RC/CO/SN/SQ
##712C2
A Read/Claim dispatch for a store failed because of an address conflict.  Two RC machines will never both work on the same line or line in the same congruence class at the same time.
#163,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_OTHER,L2 slice C RC store dispatch attempt failed due to other reasons
##732E2
A Read/Claim dispatch for a store  failed for some reason other than Full or Collision conditions.  Rejected dispatches do not count because they have not yet been attempted.
#164,v,g,n,s,PM_L2SC_RCST_DISP_FAIL_RC_FULL,L2 slice C RC store dispatch attempt failed due to all RC full
##722E1
A Read/Claim dispatch for a store failed because all RC machines are busy.
#165,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY,L2 slice C RC dispatch attempt failed due to RC/CO pair chosen was miss and CO already busy
##703C2
A Read/Claim  Dispatch was rejected at dispatch because the Castout Machine was busy.  In the case of an RC starting up on a miss and the victim is valid, the CO machine must be available for the RC to process the access. If the CO is still busy working on an old castout, then the RC must not-ack the access if it is a miss(re-issued by the CIU). If it is a miss and the CO is available to process the castout, the RC will accept the access. Once the RC has finished, it can restart and process new accesses that result in a hit (or miss that doesn't need a CO) even though the CO is still processing a castout from a previous access.
#166,v,g,n,s,PM_L2SC_RC_DISP_FAIL_CO_BUSY_ALL,L2 slice C RC dispatch attempt failed due to all CO busy
##713C2
A Read/Claim dispatch was rejected because all Castout machines were busy.
#167,v,g,n,s,PM_L2SC_SHR_INV,L2 slice C transition from shared to invalid
##710C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L, or Tagged) to the Invalid state. This transition was caused by any external snoop request. The event is provided on each of the three slices A, B, and C. NOTE: For this event to be useful the tablewalk duration event should also be counted.
#168,v,g,n,s,PM_L2SC_SHR_MOD,L2 slice C transition from shared to modified
##700C2
A cache line in the local L2 directory made a state transition from Shared (Shared, Shared L , or Tagged) to the Modified state. This transition was caused by a store from either of the two local CPUs to a cache line in any of the Shared states. The event is provided on each of the three slices A, B, and C.
#169,v,g,n,n,PM_L2SC_ST_HIT,L2 slice C store hits
##733E2
A store request made from the core hit in the L2 directory.  The event is provided on each of the  three slices A, B, and C.
#170,v,g,n,n,PM_L2SC_ST_REQ,L2 slice C store requests
##723E2
A store request as seen at the L2 directory has been made from the core. Stores are counted after gathering in the L2 store queues. The event is provided on each of the three slices A, B, and C.
#171,v,g,n,n,PM_L2_PREF,L2 cache prefetches
##C50C3
A request to prefetch data into L2 was made
#172,v,g,n,s,PM_L3SA_ALL_BUSY,L3 slice A active for every cycle all CI/CO machines busy
##721E3
Cycles All Castin/Castout machines are busy.
#173,v,g,n,s,PM_L3SA_HIT,L3 slice A hits
##711C3
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#174,v,g,n,s,PM_L3SA_MOD_INV,L3 slice A transition from modified to invalid
##730E3
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#175,v,g,n,s,PM_L3SA_MOD_TAG,L3 slice A transition from modified to TAG
##720E3
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case) Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#176,v,g,n,s,PM_L3SA_REF,L3 slice A references
##701C3
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#177,v,g,n,s,PM_L3SA_SHR_INV,L3 slice A transition from shared to invalid
##710C3
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#178,v,g,n,s,PM_L3SA_SNOOP_RETRY,L3 slice A snoop retries
##731E3
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#179,v,g,n,s,PM_L3SB_ALL_BUSY,L3 slice B active for every cycle all CI/CO machines busy
##721E4
Cycles All Castin/Castout machines are busy.
#180,v,g,n,s,PM_L3SB_HIT,L3 slice B hits
##711C4
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 slice
#181,v,g,n,s,PM_L3SB_MOD_INV,L3 slice B transition from modified to invalid
##730E4
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I).  Mu|Me are not included since they are formed due to a prev read op.  Tx is not included since it is considered shared at this point.
#182,v,g,n,s,PM_L3SB_MOD_TAG,L3 slice B transition from modified to TAG
##720E4
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#183,v,g,n,s,PM_L3SB_REF,L3 slice B references
##701C4
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice
#184,v,g,n,s,PM_L3SB_SHR_INV,L3 slice B transition from shared to invalid
##710C4
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#185,v,g,n,s,PM_L3SB_SNOOP_RETRY,L3 slice B snoop retries
##731E4
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#186,v,g,n,s,PM_L3SC_ALL_BUSY,L3 slice C active for every cycle all CI/CO machines busy
##721E5
Cycles All Castin/Castout machines are busy.
#187,v,g,n,s,PM_L3SC_HIT,L3 slice C hits
##711C5
Number of attempts made by this chip cores that resulted in an L3 hit.  Reported per L3 Slice
#188,v,g,n,s,PM_L3SC_MOD_INV,L3 slice C transition from modified to invalid
##730E5
L3 snooper detects someone doing a store to a line that is truly M in this L3 (i.e. L3 going M=>I)  Mu|Me are not included since they are formed due to a previous read op Tx is not included since it is considered shared at this point.
#189,v,g,n,s,PM_L3SC_MOD_TAG,L3 slice C transition from modified to TAG
##720E5
L3 snooper detects someone doing a read to a line that is truly M in this L3(i.e. L3 going M->T or M->I(go_Mu case); Mu|Me are not included since they are formed due to a prev read op).  Tx is not included since it is considered shared at this point.
#190,v,g,n,s,PM_L3SC_REF,L3 slice C references
##701C5
Number of attempts made by this chip cores to find data in the L3. Reported per L3 slice.
#191,v,g,n,s,PM_L3SC_SHR_INV,L3 slice C transition from shared to invalid
##710C5
L3 snooper detects someone doing a store to a line that is Sx in this L3(i.e. invalidate hit SX and dispatched).
#192,v,g,n,s,PM_L3SC_SNOOP_RETRY,L3 slice C snoop retries
##731E5
Number of times an L3 retried a snoop because it got two in at the same time (one on snp_a, one on snp_b)
#193,v,g,n,n,PM_LARX_LSU0,Larx executed on LSU0
##820E7
A larx (lwarx or ldarx) was executed on side 0 (there is no corresponding unit 1 event since larx instructions can only execute on unit 0)
#194,v,g,n,n,PM_LD_MISS_L1_LSU0,LSU0 L1 D cache load misses
##C10C2
Load references that miss the Level 1 Data cache, by unit 0.
#195,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C6
Load references that miss the Level 1 Data cache, by unit 1.
#196,v,g,n,n,PM_LD_REF_L1,L1 D cache load references
##C1090
Load references to the Level 1 Data Cache. Combined unit 0 + 1.
#197,v,g,n,n,PM_LD_REF_L1_LSU0,LSU0 L1 D cache load references
##C10C0
Load references to Level 1 Data Cache, by unit 0.
#198,v,g,n,n,PM_LD_MISS_L1_LSU1,LSU1 L1 D cache load misses
##C10C5
Load references that miss the Level 1 Data cache, by unit 1.
#199,u,g,n,s,PM_LR_CTR_MAP_FULL_CYC,Cycles LR/CTR mapper full
##100C6
The LR/CTR mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#200,v,g,n,n,PM_LSU0_BUSY_REJECT,LSU0 busy due to reject
##C20E1
Total cycles the Load Store Unit 0 is busy rejecting instructions.
#201,v,g,n,n,PM_LSU0_DERAT_MISS,LSU0 DERAT misses
##800C2
Total D-ERAT Misses by LSU0.   Requests that miss the Derat are rejected and retried until the request hits in the Erat. This may result in multiple erat misses for the same instruction.
#202,v,g,n,n,PM_LSU0_FLUSH_LRQ,LSU0 LRQ flushes
##C00C2
A load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#203,u,g,n,n,PM_LSU0_FLUSH_SRQ,LSU0 SRQ lhs flushes
##C00C3
A store was flushed by unit 0 because younger load hits and older store that is already in the SRQ or in the same group.
#204,v,g,n,n,PM_LSU0_FLUSH_ULD,LSU0 unaligned load flushes
##C00C0
A load was flushed from unit 0 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1)
#205,v,g,n,n,PM_LSU0_FLUSH_UST,LSU0 unaligned store flushes
##C00C1
A store was flushed from unit 0 because it was unaligned (crossed a 4K boundary).
#206,v,g,n,n,PM_LSU0_LDF,LSU0 executed Floating Point load instruction
##C50C0
A floating point load was executed by LSU0
#207,v,g,n,n,PM_LSU0_NCLD,LSU0 non-cacheable loads
##C50C1
A non-cacheable load was executed by unit 0.
#208,v,g,n,n,PM_LSU0_REJECT_ERAT_MISS,LSU0 reject due to ERAT miss
##C40C3
Total cycles the Load Store Unit 0 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#209,v,g,n,n,PM_LSU0_REJECT_LMQ_FULL,LSU0 reject due to LMQ full or missed data coming
##C40C1
Total cycles the Load Store Unit 0 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#210,v,g,n,n,PM_LSU0_REJECT_RELOAD_CDF,LSU0 reject due to reload CDF or tag update collision
##C40C2
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#211,v,g,n,n,PM_LSU0_REJECT_SRQ,LSU0 SRQ lhs rejects
##C40C0
Total cycles the Load Store Unit 0 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#212,u,g,n,n,PM_LSU0_SRQ_STFWD,LSU0 SRQ store forwarded
##C60E1
Data from a store instruction was forwarded to a load on unit 0.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#213,v,g,n,n,PM_LSU1_BUSY_REJECT,LSU1 busy due to reject
##C20E5
Total cycles the Load Store Unit 1 is busy rejecting instructions.
#214,v,g,n,n,PM_LSU1_DERAT_MISS,LSU1 DERAT misses
##800C6
A data request (load or store) from LSU Unit 1 missed the ERAT and resulted in an ERAT reload. Multiple instructions may miss the ERAT entry for the same 4K page, but only one reload will occur.
#215,v,g,n,n,PM_LSU1_FLUSH_LRQ,LSU1 LRQ flushes
##C00C6
A load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#216,u,g,n,n,PM_LSU1_FLUSH_SRQ,LSU1 SRQ lhs flushes
##C00C7
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#217,v,g,n,n,PM_LSU1_FLUSH_ULD,LSU1 unaligned load flushes
##C00C4
A load was flushed from unit 1 because it was unaligned (crossed a 64 byte boundary, or 32 byte if it missed the L1).
#218,u,g,n,n,PM_LSU1_FLUSH_UST,LSU1 unaligned store flushes
##C00C5
A store was flushed from unit 1 because it was unaligned (crossed a 4K boundary)
#219,v,g,n,n,PM_LSU1_LDF,LSU1 executed Floating Point load instruction
##C50C4
A floating point load was executed by LSU1
#220,v,g,n,n,PM_LSU1_NCLD,LSU1 non-cacheable loads
##C50C5
A non-cacheable load was executed by Unit 0.
#221,v,g,n,n,PM_LSU1_REJECT_ERAT_MISS,LSU1 reject due to ERAT miss
##C40C7
Total cycles the Load Store Unit 1 is busy rejecting instructions due to an ERAT miss.  Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#222,v,g,n,n,PM_LSU1_REJECT_LMQ_FULL,LSU1 reject due to LMQ full or missed data coming
##C40C5
Total cycles the Load Store Unit 1 is busy rejecting instructions because the Load Miss Queue was full. The LMQ has eight entries.  If all eight entries are full, subsequent load instructions are rejected.
#223,v,g,n,n,PM_LSU1_REJECT_RELOAD_CDF,LSU1 reject due to reload CDF or tag update collision
##C40C6
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Critical Data Forward.  When critical data arrives from the storage system it is formatted and immediately forwarded, bypassing the data cache, to the destination register using the result bus.  Any instruction the requires the result bus in the same cycle is rejected.  Tag update rejects are caused when an instruction requires access to the Dcache directory or ERAT in the same system when they are being updated.
#224,v,g,n,n,PM_LSU1_REJECT_SRQ,LSU1 SRQ lhs rejects
##C40C4
Total cycles the Load Store Unit 1 is busy rejecting instructions because of Load Hit Store conditions.  Loads are rejected when data is needed from a previous store instruction but store forwarding is not possible because the data is not fully contained in the Store Data Queue or is not yet available in the Store Data Queue.
#225,u,g,n,n,PM_LSU1_SRQ_STFWD,LSU1 SRQ store forwarded
##C60E5
Data from a store instruction was forwarded to a load on unit 1.  A load that misses L1 but becomes a store forward is treated as a load miss and it causes the DL1 load miss event to be counted.  It does not go into the LMQ. If a load that hits L1 but becomes a store forward, then it's not treated as a load miss.
#226,v,g,n,n,PM_LSU_FLUSH,Flush initiated by LSU
##110C5
A flush was initiated by the Load Store Unit
#227,v,g,n,s,PM_LSU_FLUSH_LRQ_FULL,Flush caused by LRQ full
##320E7
This thread was flushed at dispatch because its Load Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#228,u,g,n,n,PM_LSU_FLUSH_SRQ,SRQ flushes
##C00A8
A store was flushed because younger load hits and older store that is already in the SRQ or in the same group.  Combined Unit 0 + 1.
#229,v,g,n,s,PM_LSU_FLUSH_SRQ_FULL,Flush caused by SRQ full
##330E0
This thread was flushed at dispatch because its Store Request Queue was full. This allows the other thread to have more machine resources for it to make progress while this thread is stalled.
#230,v,g,n,n,PM_LSU_LDF,LSU executed Floating Point load instruction
##C5090
LSU executed Floating Point load instruction.  Combined Unit 0 + 1.
#231,u,g,n,s,PM_LSU_LMQ_FULL_CYC,Cycles LMQ full
##C30E7
The Load Miss Queue was full.
#232,v,g,n,n,PM_LSU_LMQ_LHR_MERGE,LMQ LHR merges
##C70E5
A data cache miss occurred for the same real cache line address as an earlier request already in the Load Miss Queue and was merged into the LMQ entry.
#233,v,g,n,s,PM_LSU_LMQ_S0_ALLOC,LMQ slot 0 allocated
##C30E6
The first entry in the LMQ was allocated.
#234,v,g,n,n,PM_LSU_LMQ_S0_VALID,LMQ slot 0 valid
##C30E5
This signal is asserted every cycle when the first entry in the LMQ is valid. The LMQ had eight entries that are allocated FIFO
#235,v,g,n,s,PM_LSU_LRQ_FULL_CYC,Cycles LRQ full
##110C2
Cycles when the LRQ is full.
#236,v,g,n,n,PM_LSU_LRQ_S0_ALLOC,LRQ slot 0 allocated
##C60E7
LRQ slot zero was allocated
#237,v,g,n,n,PM_LSU_LRQ_S0_VALID,LRQ slot 0 valid
##C60E6
This signal is asserted every cycle that the Load Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the LRQ is split between the two threads (16 entries each).
#238,v,g,n,n,PM_LSU_REJECT_ERAT_MISS,LSU reject due to ERAT miss
##C40A8
Total cycles the Load Store Unit is busy rejecting instructions due to an ERAT miss. Combined unit 0 + 1. Requests that miss the Derat are rejected and retried until the request hits in the Erat.
#239,u,g,n,n,PM_LSU_SRQ_EMPTY_CYC,Cycles SRQ empty
##00015
Cycles the Store Request Queue is empty
#240,v,g,n,s,PM_LSU_SRQ_FULL_CYC,Cycles SRQ full
##110C3
Cycles the Store Request Queue is full.
#241,v,g,n,n,PM_LSU_SRQ_S0_ALLOC,SRQ slot 0 allocated
##C20E7
SRQ Slot zero was allocated
#242,v,g,n,n,PM_LSU_SRQ_S0_VALID,SRQ slot 0 valid
##C20E6
This signal is asserted every cycle that the Store Request Queue slot zero is valid. The SRQ is 32 entries long and is allocated round-robin.  In SMT mode the SRQ is split between the two threads (16 entries each).
#243,u,g,n,n,PM_LSU_SRQ_SYNC_CYC,SRQ sync duration
##830E5
Cycles that a sync instruction is active in the Store Request Queue.
#244,v,g,n,n,PM_LWSYNC_HELD,LWSYNC held at dispatch
##130E0
Cycles a LWSYNC instruction was held at dispatch. LWSYNC instructions are held at dispatch until all previous loads are done and all previous stores have issued. LWSYNC enters the Store Request Queue and is sent to the storage subsystem but does not wait for a response.
#245,c,g,n,n,PM_MEM_FAST_PATH_RD_DISP,Fast path memory read dispatched
##731E6
Fast path memory read dispatched
#246,v,g,n,n,PM_MEM_RQ_DISP_Q16to19,Memory read queue dispatched to queues 16-19
##727E6
A memory operation was dispatched to read queue 16,17,18 or 19. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#247,v,g,n,s,PM_MEM_HI_PRIO_WR_CMPL,High priority write completed
##726E6
A memory write,  which was upgraded to high priority, completed.  Writes can be upgraded to high priority to ensure that read traffic does not lock out writes. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#248,v,g,n,n,PM_MEM_RQ_DISP_Q12to15,Memory read queue dispatched to queues 12-15
##732E6
A memory operation was dispatched to read queue 12,13,14 or 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#249,v,g,n,s,PM_MEM_LO_PRIO_WR_CMPL,Low priority write completed
##736E6
A memory write,  which was not upgraded to high priority, completed.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#250,v,g,n,s,PM_MEM_PWQ_DISP,Memory partial-write queue dispatched
##704C6
Number of Partial Writes dispatched.  The MC provides resources to gather partial cacheline writes (Partial line DMA writes & CI-stores) to up to four different cachelines at a time.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#251,v,g,n,n,PM_MEM_PWQ_DISP_Q2or3,Memory partial-write queue dispatched to Write Queue 2 or 3
##734E6
Memory partial-write queue dispatched to Write Queue 2 or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#252,v,g,n,s,PM_MEM_PW_CMPL,Memory partial-write completed
##724E6
Number of Partial Writes completed.   This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#253,v,g,n,s,PM_MEM_PW_GATH,Memory partial-write gathered
##714C6
Two or more partial-writes have been merged into a single memory write. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#254,v,g,n,n,PM_INST_DISP_ATTEMPT,Instructions dispatch attempted
##120E1
Number of PowerPC Instructions dispatched (attempted, not filtered by success.
#255,v,g,n,s,PM_MEM_RQ_DISP,Memory read queue dispatched
##701C6
A memory read was dispatched. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#256,v,g,n,n,PM_MEM_RQ_DISP_Q0to3,Memory read queue dispatched to queues 0-3
##702C6
A memory operation was dispatched to read queue 0,1,2, or 3. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#257,v,g,n,n,PM_MEM_RQ_DISP_Q4to7,Memory read queue dispatched to queues 4-7
##712C6
A memory operation was dispatched to read queue 4,5,6 or 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#258,v,g,n,s,PM_MEM_SPEC_RD_CANCEL,Speculative memory read cancelled
##721E6
Speculative memory read cancelled (i.e. cresp = sourced by L2/L3)
#259,v,g,n,n,PM_MEM_WQ_DISP_Q0to7,Memory write queue dispatched to queues 0-7
##723E6
A memory operation was dispatched to a write queue in the range between 0 and 7. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#260,v,g,n,n,PM_MEM_WQ_DISP_Q8to15,Memory write queue dispatched to queues 8-15
##733E6
A memory operation was dispatched to a write queue in the range between 8 and 15. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#261,v,g,n,s,PM_MEM_WQ_DISP_DCLAIM,Memory write queue dispatched due to dclaim/flush
##713C6
A memory dclaim or flush operation was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#262,v,g,n,s,PM_MEM_WQ_DISP_WRITE,Memory write queue dispatched due to write
##703C6
A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#263,v,g,n,n,PM_MRK_CRU_FIN,Marked instruction CRU processing finished
##00005
The Condition Register Unit finished a marked instruction. Instructions that finish may not necessary complete.
#264,v,g,n,n,PM_MRK_DATA_FROM_L25_MOD_CYC,Marked load latency from L2.5 modified
##C70A2
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#265,v,g,n,n,PM_MRK_DATA_FROM_L275_MOD,Marked data loaded from L2.75 modified
##C7097
The processor's Data Cache was reloaded with modified (M) data from the L2 on a different module than this processor is located due to a marked load.
#266,v,g,n,n,PM_MRK_DATA_FROM_L275_MOD_CYC,Marked load latency from L2.75 modified
##C70A3
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#267,v,g,n,n,PM_MRK_DATA_FROM_L35_MOD_CYC,Marked load latency from L3.5 modified
##C70A6
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#268,v,g,n,n,PM_MRK_DATA_FROM_L375_MOD,Marked data loaded from L3.75 modified
##C709E
The processor's Data Cache was reloaded with modified  (M) data from the L3 of a chip on a different module than this processor is located due to a marked load.
#269,v,g,n,n,PM_MRK_DATA_FROM_L375_MOD_CYC,Marked load latency from L3.75 modified
##C70A7
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#270,v,g,n,n,PM_MRK_DATA_FROM_LMEM_CYC,Marked load latency from local memory
##C70A0
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#271,v,g,n,n,PM_MRK_DATA_FROM_RMEM,Marked data loaded from remote memory
##C7087
The processor's Data Cache was reloaded due to a marked load from memory attached to a different module than this proccessor is located on.
#272,v,g,n,n,PM_MRK_DATA_FROM_RMEM_CYC,Marked load latency from remote memory
##C70A1
Cycles a marked load waited for data from this level of the storage system.  Counting begins when a marked load misses the data cache and ends when the data is reloaded into the data cache.  To calculate average latency divide this count by the number of marked misses to the same level.
#273,v,g,n,n,PM_MRK_DSLB_MISS,Marked Data SLB misses
##C50C7
A Data SLB miss was caused by a marked instruction.
#274,v,g,n,n,PM_MRK_DTLB_MISS,Marked Data TLB misses
##C50C6,C60E0
Data TLB references by a marked instruction that missed the TLB (all page sizes).
#275,v,g,n,n,PM_MRK_DTLB_MISS_16G,Marked Data TLB misses for 16G page
##C608D
Data TLB references to 16GB pages by a marked instruction that missed the TLB. Page size is determined at TLB reload time.
#276,v,g,n,n,PM_MRK_DTLB_REF,Marked Data TLB reference
##C60E4
Total number of Data TLB references by a marked instruction for all page sizes. Page size is determined at TLB reload time.
#277,v,g,n,n,PM_MRK_DTLB_REF_16G,Marked Data TLB reference for 16G page
##C6086
Data TLB references by a marked instruction for 16GB pages.
#278,v,g,n,n,PM_MRK_GRP_CMPL,Marked group completed
##00013
A group containing a sampled instruction completed.  Microcoded instructions that span multiple groups will generate this event once per group.
#279,v,g,n,n,PM_MRK_GRP_IC_MISS,Group experienced marked I cache miss
##12091
A group containing a marked (sampled) instruction experienced an instruction cache miss.
#280,v,g,n,n,PM_MRK_GRP_TIMEO,Marked group completion timeout
##0000B
The sampling timeout expired indicating that the previously sampled instruction is no longer in the processor
#281,v,g,n,n,PM_MRK_IMR_RELOAD,Marked IMR reloaded
##820E2
A DL1 reload occurred due to marked load
#282,v,g,n,n,PM_MRK_L1_RELOAD_VALID,Marked L1 reload data source valid
##C70E4
The source information is valid and is for a marked load
#283,v,g,n,n,PM_MRK_LD_MISS_L1_LSU0,LSU0 marked L1 D cache load misses
##820E0
Load references that miss the Level 1 Data cache, by LSU0.
#284,v,g,n,n,PM_MRK_LD_MISS_L1_LSU1,LSU1 marked L1 D cache load misses
##820E4
Load references that miss the Level 1 Data cache, by LSU1.
#285,v,g,n,n,PM_MRK_LSU0_FLUSH_LRQ,LSU0 marked LRQ flushes
##810C2
A marked load was flushed by unit 0 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#286,u,g,n,n,PM_MRK_LSU0_FLUSH_SRQ,LSU0 marked SRQ lhs flushes
##810C3
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#287,v,g,n,n,PM_MRK_LSU0_FLUSH_ULD,LSU0 marked unaligned load flushes
##810C1
A marked load was flushed from unit 0 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#288,v,g,n,n,PM_MRK_LSU0_FLUSH_UST,LSU0 marked unaligned store flushes
##810C0
A marked store was flushed from unit 0 because it was unaligned
#289,v,g,n,n,PM_MRK_LSU1_FLUSH_LRQ,LSU1 marked LRQ flushes
##810C6
A marked load was flushed by unit 1 because a younger load executed before an older store executed and they had overlapping data OR two loads executed out of order and they have byte overlap and there was a snoop in between to an overlapped byte.
#290,u,g,n,n,PM_MRK_LSU1_FLUSH_SRQ,LSU1 marked SRQ lhs flushes
##810C7
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#291,v,g,n,n,PM_MRK_LSU1_FLUSH_ULD,LSU1 marked unaligned load flushes
##810C4
A marked load was flushed from unit 1 because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#292,u,g,n,n,PM_MRK_LSU1_FLUSH_UST,LSU1 marked unaligned store flushes
##810C5
A marked store was flushed from unit 1 because it was unaligned (crossed a 4k boundary)
#293,c,g,n,n,PM_MRK_LSU_FIN,Marked instruction LSU processing finished
##00014
One of the Load/Store Units finished a marked instruction. Instructions that finish may not necessary complete
#294,v,g,n,n,PM_MRK_LSU_FLUSH_SRQ,Marked SRQ lhs flushes
##81088
A marked store was flushed because younger load hits and older store that is already in the SRQ or in the same group.
#295,v,g,n,n,PM_MRK_LSU_FLUSH_ULD,Marked unaligned load flushes
##81090
A marked load was flushed because it was unaligned (crossed a 64byte boundary, or 32 byte if it missed the L1)
#296,u,g,n,n,PM_MRK_LSU_SRQ_INST_VALID,Marked instruction valid in SRQ
##C70E6
This signal is asserted every cycle when a marked request is resident in the Store Request Queue
#297,v,g,n,n,PM_MRK_STCX_FAIL,Marked STCX failed
##820E6
A marked stcx (stwcx or stdcx) failed
#298,v,g,n,n,PM_MRK_ST_MISS_L1,Marked L1 D cache store misses
##820E3
A marked store missed the dcache
#299,v,g,n,n,PM_PMC3_OVERFLOW,PMC3 Overflow
##0000A
Overflows from PMC3 are counted.  This effectively widens the PMC. The Overflow from the original PMC will not trigger an exception even if the PMU is configured to generate exceptions on overflow.
#300,v,g,n,n,PM_PTEG_FROM_L275_MOD,PTEG loaded from L2.75 modified
##83097
A Page Table Entry was loaded into the TLB with modified (M) data from the L2 on a different module than this processor is located due to a demand load.
#301,v,g,n,n,PM_PTEG_FROM_L375_MOD,PTEG loaded from L3.75 modified
##8309E
A Page Table Entry was loaded into the TLB with modified  (M) data from the L3 of a chip on a different module than this processor is located, due to a demand load.
#302,v,g,n,n,PM_PTEG_FROM_RMEM,PTEG loaded from remote memory
##83087
A Page Table Entry was loaded into the TLB from memory attached to a different module than this proccessor is located on.
#303,v,g,n,n,PM_PTEG_RELOAD_VALID,PTEG reload valid
##830E4
A Page Table Entry was loaded into the TLB.
#304,v,g,n,s,PM_SNOOP_DCLAIM_RETRY_QFULL,Snoop dclaim/flush retry due to write/dclaim queues full
##720E6
The memory controller A memory write was dispatched to a write queue. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#305,v,g,n,s,PM_SNOOP_PARTIAL_RTRY_QFULL,Snoop partial write retry due to partial-write queues full
##730E6
A snoop request for a partial write to memory was retried because the write queues that handle partial writes were full. When this happens the active writes are changed to high priority. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#306,v,g,n,s,PM_SNOOP_PW_RETRY_RQ,Snoop partial-write retry due to collision with active read queue
##707C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#307,v,g,n,s,PM_SNOOP_PW_RETRY_WQ_PWQ,Snoop partial-write retry due to collision with active write or partial-write queue
##717C6
A snoop request for a partial write to memory was retried because it matched the cache line of an active write or partial write.  When this happens the snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#308,v,g,n,s,PM_SNOOP_RD_RETRY_QFULL,Snoop read retry due to read queue full
##700C6
A snoop request for a read from memory was retried because the read queues were full.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#309,v,g,n,s,PM_SNOOP_RD_RETRY_RQ,Snoop read retry due to collision with active read queue
##705C6
A snoop request for a read from memory was retried because it matched the cache line of an active read.  The snoop request is retried because the L2 may be able to source data via intervention for the 2nd read faster than the MC.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#310,v,g,n,s,PM_SNOOP_RD_RETRY_WQ,Snoop read retry due to collision with active write queue
##715C6
A snoop request for a read from memory was retried because it matched the cache line of an active write. The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#311,v,g,n,s,PM_SNOOP_RETRY_1AHEAD,Snoop retry due to one ahead collision
##725E6
Snoop retry due to one ahead collision
#312,u,g,n,s,PM_SNOOP_TLBIE,Snoop TLBIE
##800C3
A tlbie was snooped from another processor.
#313,v,g,n,s,PM_SNOOP_WR_RETRY_QFULL,Snoop read retry due to read queue full
##710C6
A snoop request for a write to memory was retried because the write queues were full.  When this happens the snoop request is retried and the writes in the write reorder queue are changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#314,v,g,n,s,PM_SNOOP_WR_RETRY_RQ,Snoop write/dclaim retry due to collision with active read queue
##706C6
A snoop request for a write or dclaim to memory was retried because it matched the cacheline of an active read.  This event is sent from the Memory Controller clock domain and must be scaled accordingly
#315,v,g,n,s,PM_SNOOP_WR_RETRY_WQ,Snoop write/dclaim retry due to collision with active write queue
##716C6
A snoop request for a write or dclaim to memory was retried because it matched the cache line of an active write.  The snoop request is retried and the active write is changed to high priority.  This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#316,v,g,n,n,PM_STCX_FAIL,STCX failed
##820E1
A stcx (stwcx or stdcx) failed
#317,v,g,n,n,PM_STCX_PASS,Stcx passes
##820E5
A stcx (stwcx or stdcx) instruction was successful
#318,v,g,n,n,PM_ST_MISS_L1,L1 D cache store misses
##C10C3
A store missed the dcache.  Combined Unit 0 + 1.
#319,v,g,n,n,PM_ST_REF_L1_LSU0,LSU0 L1 D cache store references
##C10C1
Store references to the Data Cache by LSU0.
#320,v,g,n,n,PM_ST_REF_L1_LSU1,LSU1 L1 D cache store references
##C10C4
Store references to the Data Cache by LSU1.
#321,v,g,n,n,PM_SUSPENDED,Suspended
##00000
The counter is suspended (does not count).
#322,v,g,n,s,PM_THRD_L2MISS_BOTH_CYC,Cycles both threads in L2 misses
##41084,410C7
Cycles that both threads have L2 miss pending.  If only one thread has a L2 miss pending the other thread is given priority at decode.  If both threads have L2 miss pending decode priority is determined by the number of GCT entries used.
#323,v,g,n,n,PM_THRD_PRIO_1_CYC,Cycles thread running at priority level 1
##420E0
Cycles this thread was running at priority level 1. Priority level 1 is the lowest and indicates the thread is sleeping.
#324,v,g,n,n,PM_THRD_PRIO_2_CYC,Cycles thread running at priority level 2
##420E1
Cycles this thread was running at priority level 2.
#325,v,g,n,n,PM_THRD_PRIO_3_CYC,Cycles thread running at priority level 3
##420E2
Cycles this thread was running at priority level 3.
#326,v,g,n,n,PM_THRD_PRIO_4_CYC,Cycles thread running at priority level 4
##420E3
Cycles this thread was running at priority level 4.
#327,v,g,n,n,PM_THRD_PRIO_5_CYC,Cycles thread running at priority level 5
##420E4
Cycles this thread was running at priority level 5.
#328,v,g,n,n,PM_THRD_PRIO_6_CYC,Cycles thread running at priority level 6
##420E5
Cycles this thread was running at priority level 6.
#329,v,g,n,n,PM_THRD_PRIO_7_CYC,Cycles thread running at priority level 7
##420E6
Cycles this thread was running at priority level 7.
#330,v,g,n,n,PM_THRD_PRIO_DIFF_0_CYC,Cycles no thread priority difference
##430E3
Cycles when this thread's priority is equal to the other thread's priority.
#331,v,g,n,n,PM_THRD_PRIO_DIFF_1or2_CYC,Cycles thread priority difference is 1 or 2
##430E4
Cycles when this thread's priority is higher than the other thread's priority by 1 or 2.
#332,v,g,n,n,PM_THRD_PRIO_DIFF_3or4_CYC,Cycles thread priority difference is 3 or 4
##430E5
Cycles when this thread's priority is higher than the other thread's priority by 3 or 4.
#333,v,g,n,n,PM_THRD_PRIO_DIFF_5or6_CYC,Cycles thread priority difference is 5 or 6
##430E6
Cycles when this thread's priority is higher than the other thread's priority by 5 or 6.
#334,v,g,n,n,PM_THRD_PRIO_DIFF_minus1or2_CYC,Cycles thread priority difference is -1 or -2
##430E2
Cycles when this thread's priority is lower than the other thread's priority by 1 or 2.
#335,v,g,n,n,PM_THRD_PRIO_DIFF_minus3or4_CYC,Cycles thread priority difference is -3 or -4
##430E1
Cycles when this thread's priority is lower than the other thread's priority by 3 or 4.
#336,v,g,n,n,PM_THRD_PRIO_DIFF_minus5or6_CYC,Cycles thread priority difference is -5 or -6
##430E0
Cycles when this thread's priority is lower than the other thread's priority by 5 or 6.
#337,v,g,n,s,PM_THRD_SEL_OVER_CLB_EMPTY,Thread selection overrides caused by CLB empty
##410C2
Thread selection was overridden because one thread's CLB was empty.
#338,v,g,n,s,PM_THRD_SEL_OVER_GCT_IMBAL,Thread selection overrides caused by GCT imbalance
##410C4
Thread selection was overridden because of a GCT imbalance.
#339,v,g,n,s,PM_THRD_SEL_OVER_ISU_HOLD,Thread selection overrides caused by ISU holds
##410C5
Thread selection was overridden because of an ISU hold.
#340,v,g,n,s,PM_THRD_SEL_OVER_L2MISS,Thread selection overrides caused by L2 misses
##410C3
Thread selection was overridden because one thread was had a L2 miss pending.
#341,v,g,n,s,PM_THRD_SEL_T0,Decode selected thread 0
##410C0
Thread selection picked thread 0 for decode.
#342,v,g,n,s,PM_THRD_SEL_T1,Decode selected thread 1
##410C1
Thread selection picked thread 1 for decode.
#343,v,g,n,s,PM_THRD_SMT_HANG,SMT hang detected
##330E7
A hung thread was detected
#344,v,g,n,n,PM_TLBIE_HELD,TLBIE held at dispatch
##130E4
Cycles a TLBIE instruction was held at dispatch.
#345,v,g,n,n,PM_WORK_HELD,Work held
##0000C
RAS Unit has signaled completion to stop and there are groups waiting to complete
#346,v,g,n,s,PM_XER_MAP_FULL_CYC,Cycles XER mapper full
##100C2
The XER mapper cannot accept any more groups. This condition will prevent dispatch groups from being dispatched.  This event only indicates that the mapper was full, not that dispatch was prevented.
#347,v,g,n,n,PM_BR_PRED_CR,A conditional branch was predicted, CR prediction
##230E2
A conditional branch instruction was predicted as taken or not taken.
#348,v,g,n,n,PM_BR_PRED_TA,A conditional branch was predicted, target prediction
##230E3
The target address of a branch instruction was predicted.
#349,v,g,n,n,PM_MEM_RQ_DISP_Q8to11,Memory read queue dispatched to queues 8-11
##722E6
A memory operation was dispatched to read queue 8,9,10 or 11. This event is sent from the Memory Controller clock domain and must be scaled accordingly.
#350,v,g,n,n,PM_SNOOP_RETRY_AB_COLLISION,Snoop retry due to a b collision
##735E6
Snoop retry due to a b collision
#351,v,g,n,s,PM_MEM_NONSPEC_RD_CANCEL,Non speculative memory read cancelled
##711C6
A non-speculative read was cancelled because the combined response indicated it was sourced from aother L2 or L3.   This event is sent from the Memory Controller clock domain and must be scaled accordingly

$$$$$$$$

{ counter 5 }
#0,v,g,n,n,PM_RUN_INST_CMPL,Run instructions completed
##00009
Number of run instructions completed.

$$$$$$$$

{ counter 6 }
#0,v,g,n,n,PM_RUN_CYC,Run cycles
##00005
Processor Cycles gated by the run latch.  Operating systems use the run latch to indicate when they are doing useful work.  The run latch is typically cleared in the OS idle loop.  Gating by the run latch filters out the idle loop.
